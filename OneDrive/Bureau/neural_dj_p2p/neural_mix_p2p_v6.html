<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuralMix P2P - Collaborative DJ Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a0e2e 50%, #0c0c0c 100%);
            color: white;
            font-family: 'Monaco', 'Menlo', monospace;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(59, 130, 246, 0.2));
            border-radius: 15px;
            border: 1px solid rgba(168, 85, 247, 0.3);
        }

        .title {
            font-size: 3rem;
            font-weight: bold;
            background: linear-gradient(to right, #a855f7, #ec4899, #22d3ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #22d3ee;
            margin-bottom: 5px;
        }

        .description {
            font-size: 0.9rem;
            color: #9ca3af;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .deck {
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.8), rgba(55, 65, 81, 0.8));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .deck-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(168, 85, 247, 0.3);
        }

        .deck-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #a855f7;
        }

        .deck-status {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .center-mixer {
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.9), rgba(75, 85, 99, 0.9));
            border: 1px solid rgba(236, 72, 153, 0.4);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .mixer-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .mixer-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ec4899;
            margin-bottom: 5px;
        }

        .file-upload {
            margin-bottom: 20px;
        }

        .file-upload input[type="file"] {
            width: 100%;
            padding: 10px;
            background: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            color: white;
            font-family: monospace;
        }

        .waveform-container {
            height: 120px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }

        .control-label {
            display: block;
            font-size: 0.8rem;
            font-weight: bold;
            color: #d1d5db;
            margin-bottom: 8px;
            text-align: center;
        }

        .control-slider {
            width: 100%;
            height: 40px;
            background: linear-gradient(to right, #374151, #6b7280);
            border-radius: 20px;
            position: relative;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .control-value {
            text-align: center;
            font-size: 0.8rem;
            color: #9ca3af;
            font-family: monospace;
        }

        .crossfader-section {
            margin: 30px 0;
            padding: 20px;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(236, 72, 153, 0.2));
            border: 1px solid rgba(168, 85, 247, 0.4);
            border-radius: 12px;
        }

        .crossfader-label {
            text-align: center;
            font-size: 1rem;
            font-weight: bold;
            color: #ec4899;
            margin-bottom: 15px;
        }

        .crossfader {
            width: 100%;
            height: 60px;
            background: linear-gradient(to right, #a855f7, #ec4899, #22d3ee);
            border-radius: 30px;
            position: relative;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .crossfader-handle {
            position: absolute;
            top: 5px;
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: left 0.1s ease;
            cursor: grab;
        }

        .crossfader-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .play-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            font-size: 2rem;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: all 0.3s ease;
        }

        .play-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }

        .play-button.playing {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .p2p-section {
            background: rgba(31, 41, 55, 0.8);
            border: 1px solid rgba(34, 211, 238, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .p2p-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .p2p-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #22d3ee;
        }

        .connection-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .connection-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }

        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(107, 114, 128, 0.5);
            border-radius: 6px;
            color: white;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .input:focus {
            outline: none;
            border-color: #22d3ee;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.3);
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #22d3ee, #06b6d4);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(34, 211, 238, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected { background: #22c55e; animation: pulse 2s infinite; }
        .status-connecting { background: #eab308; animation: pulse 1s infinite; }
        .status-disconnected { background: #6b7280; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .neural-section {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(236, 72, 153, 0.1));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .neural-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #a855f7;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sync-status {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
            margin-bottom: 15px;
        }

        .sync-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            text-align: center;
        }

        .sync-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 6px;
        }

        .sync-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #22d3ee;
            margin-bottom: 5px;
        }

        .sync-label {
            font-size: 0.8rem;
            color: #9ca3af;
        }

        .chat-section {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
            height: 200px;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .chat-message {
            font-size: 0.8rem;
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 4px;
        }

        .chat-message.system { color: #9ca3af; }
        .chat-message.peer { color: #22d3ee; }
        .chat-message.local { color: #a855f7; }

        .spectral-display {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .spectral-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .spectral-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #22d3ee;
            margin-bottom: 10px;
        }

        .spectral-canvas {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(34, 211, 238, 0.3);
        }

        .signature {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(236, 72, 153, 0.2));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 12px;
            margin-top: 30px;
        }

        .signature-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: #a855f7;
            margin-bottom: 8px;
        }

        .signature-author {
            color: #d1d5db;
            margin-bottom: 4px;
        }

        .signature-author span {
            color: #22d3ee;
            font-weight: bold;
        }

        .signature-quote {
            font-size: 0.9rem;
            color: #9ca3af;
            font-style: italic;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .connection-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1 class="title">üéß NeuralMix P2P</h1>
            <p class="subtitle">Collaborative Neural DJ Platform</p>
            <p class="description">Real-time P2P mixing with AI-powered beat sync and collaborative crossfading</p>
        </div>

        <!-- P2P Connection Section -->
        <div class="p2p-section">
            <div class="p2p-header">
                <span style="font-size: 1.5rem;">üåê</span>
                <h2 class="p2p-title">P2P Connection Hub</h2>
                <div id="connection-status">
                    <span class="status-indicator status-disconnected"></span>
                    <span id="status-text">Disconnected</span>
                </div>
            </div>
            
            <div class="connection-grid">
                <div class="connection-panel">
                    <h3 style="color: #22d3ee; margin-bottom: 10px;">Your DJ ID</h3>
                    <div class="input-group">
                        <input type="text" id="peer-id" class="input" readonly>
                        <button id="copy-id-btn" class="btn btn-primary">üìã</button>
                    </div>
                    <p style="font-size: 0.8rem; color: #9ca3af; margin-top: 8px;">Share this ID with your mixing partner</p>
                </div>
                
                <div class="connection-panel">
                    <h3 style="color: #22d3ee; margin-bottom: 10px;">Connect to DJ</h3>
                    <div class="input-group">
                        <input type="text" id="remote-peer-id" class="input" placeholder="Enter DJ ID">
                        <button id="connect-btn" class="btn btn-success">üéµ</button>
                    </div>
                    <p style="font-size: 0.8rem; color: #9ca3af; margin-top: 8px;">Join collaborative mix session</p>
                </div>
            </div>
        </div>

        <!-- Main Mixing Interface -->
        <div class="main-grid">
            <!-- Deck A -->
            <div class="deck">
                <div class="deck-header">
                    <h3 class="deck-title">DECK A</h3>
                    <span class="deck-status" id="deck-a-status">READY</span>
                </div>
                
                <div class="file-upload">
                    <input type="file" accept="audio/*" id="file-a" placeholder="Load Track A">
                </div>
                
                <div class="waveform-container">
                    <canvas id="waveform-a" class="waveform-canvas"></canvas>
                </div>
                
                <div class="controls-grid">
                    <div class="control-group">
                        <label class="control-label">VOLUME</label>
                        <div class="control-slider" data-deck="a" data-control="volume">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="volume-a-value">50%</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ HIGH</label>
                        <div class="control-slider" data-deck="a" data-control="high">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="high-a-value">0dB</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ MID</label>
                        <div class="control-slider" data-deck="a" data-control="mid">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="mid-a-value">0dB</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ LOW</label>
                        <div class="control-slider" data-deck="a" data-control="low">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="low-a-value">0dB</div>
                    </div>
                </div>
                
                <button class="play-button" id="play-a">‚ñ∂</button>
            </div>

            <!-- Center Mixer -->
            <div class="center-mixer">
                <div class="mixer-header">
                    <h3 class="mixer-title">NEURAL MIXER</h3>
                    <p style="color: #9ca3af; font-size: 0.8rem;">AI-Powered Collaborative Mixing</p>
                </div>
                
                <div class="crossfader-section">
                    <div class="crossfader-label">COLLABORATIVE CROSSFADER</div>
                    <div class="crossfader" id="crossfader">
                        <div class="crossfader-handle" id="crossfader-handle" style="left: calc(50% - 25px);"></div>
                    </div>
                    <div class="crossfader-labels">
                        <span style="color: #a855f7;">DECK A</span>
                        <span style="color: #22d3ee;">DECK B</span>
                    </div>
                </div>
                
                <div class="neural-section">
                    <h3 class="neural-title">
                        <span>üß†</span>
                        Neural Sync Engine
                    </h3>
                    
                    <div class="sync-status">
                        <div class="sync-grid">
                            <div class="sync-item">
                                <div class="sync-value" id="bpm-sync">--</div>
                                <div class="sync-label">BPM SYNC</div>
                            </div>
                            <div class="sync-item">
                                <div class="sync-value" id="beat-align">--</div>
                                <div class="sync-label">BEAT ALIGN</div>
                            </div>
                            <div class="sync-item">
                                <div class="sync-value" id="neural-confidence">--</div>
                                <div class="sync-label">AI CONFIDENCE</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chat-section">
                        <div class="chat-messages" id="chat-messages">
                            <div class="chat-message system">üéµ NeuralMix P2P initialized</div>
                            <div class="chat-message system">üß† Neural sync engine ready</div>
                        </div>
                        <div class="input-group">
                            <input type="text" id="chat-input" class="input" placeholder="Chat with DJ partner...">
                            <button id="send-chat-btn" class="btn btn-primary">üì§</button>
                            <button id="test-chat-btn" class="btn btn-success" style="padding: 8px 12px;">üß™</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Deck B -->
            <div class="deck">
                <div class="deck-header">
                    <h3 class="deck-title">DECK B</h3>
                    <span class="deck-status" id="deck-b-status">READY</span>
                </div>
                
                <div class="file-upload">
                    <input type="file" accept="audio/*" id="file-b" placeholder="Load Track B">
                </div>
                
                <div class="waveform-container">
                    <canvas id="waveform-b" class="waveform-canvas"></canvas>
                </div>
                
                <div class="controls-grid">
                    <div class="control-group">
                        <label class="control-label">VOLUME</label>
                        <div class="control-slider" data-deck="b" data-control="volume">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="volume-b-value">50%</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ HIGH</label>
                        <div class="control-slider" data-deck="b" data-control="high">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="high-b-value">0dB</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ MID</label>
                        <div class="control-slider" data-deck="b" data-control="mid">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="mid-b-value">0dB</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ LOW</label>
                        <div class="control-slider" data-deck="b" data-control="low">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="low-b-value">0dB</div>
                    </div>
                </div>
                
                <button class="play-button" id="play-b">‚ñ∂</button>
            </div>
        </div>

        <!-- Spectral Analysis Display -->
        <div class="spectral-display">
            <div class="spectral-header">
                <h3 class="spectral-title">üåä Real-Time Spectral Analysis</h3>
                <p style="color: #9ca3af;">Neural frequency analysis and collaborative mixing visualization</p>
            </div>
            <canvas id="spectral-canvas" class="spectral-canvas"></canvas>
        </div>

        <!-- Signature -->
        <div class="signature">
            <div class="signature-title">üéß NeuralMix P2P Architecture</div>
            <div class="signature-author">
                Concepteur Syst√®me : <span>Serigne Diagne</span>
            </div>
            <div class="signature-quote">
                "Quand l'intelligence artificielle transforme le mixing en exp√©rience collaborative"
            </div>
        </div>
    </div>

    <script>
        // Global State Management
        class NeuralMixState {
            constructor() {
                this.peerId = this.generatePeerId();
                this.remotePeerId = null;
                this.isConnected = false;
                this.audioContext = null;
                this.webRTC = null;
                this.dataChannel = null;
                
                this.decks = {
                    a: {
                        audio: null,
                        buffer: null,
                        source: null,
                        gainNode: null,
                        eqNodes: { high: null, mid: null, low: null },
                        analyser: null,
                        isPlaying: false,
                        bpm: null,
                        beatPhase: 0
                    },
                    b: {
                        audio: null,
                        buffer: null,
                        source: null,
                        gainNode: null,
                        eqNodes: { high: null, mid: null, low: null },
                        analyser: null,
                        isPlaying: false,
                        bpm: null,
                        beatPhase: 0
                    }
                };
                
                this.mixer = {
                    crossfaderPosition: 0.5,
                    masterVolume: 0.8
                };
                
                this.neural = {
                    beatSync: false,
                    confidence: 0,
                    syncOffset: 0
                };
            }

            generatePeerId() {
                return 'neuralmix-' + Math.random().toString(36).substr(2, 8);
            }
        }

        // Advanced Neural Beat Detection Engine
        class NeuralBeatDetector {
            constructor(audioContext) {
                this.audioContext = audioContext;
                this.detectionHistory = { a: [], b: [] };
                this.confidenceThreshold = 0.7;
                this.beatPatterns = { a: [], b: [] };
                this.keyDetection = { a: null, b: null };
                this.tempoStability = { a: 0, b: 0 };
                this.mixingSuggestions = [];
                this.learningData = [];
            }

            detectBPM(analyserNode, deck) {
                const bufferLength = analyserNode.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyserNode.getByteFrequencyData(dataArray);
                
                // Analyse multi-bande pour meilleure d√©tection
                const bassFreqs = dataArray.slice(0, Math.floor(bufferLength * 0.1));
                const midFreqs = dataArray.slice(Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.4));
                const trebleFreqs = dataArray.slice(Math.floor(bufferLength * 0.4), Math.floor(bufferLength * 0.8));
                
                const bassEnergy = bassFreqs.reduce((sum, val) => sum + val, 0) / bassFreqs.length;
                const midEnergy = midFreqs.reduce((sum, val) => sum + val, 0) / midFreqs.length;
                const trebleEnergy = trebleFreqs.reduce((sum, val) => sum + val, 0) / trebleFreqs.length;
                
                // D√©tection de kick plus sophistiqu√©e
                const kickThreshold = this.adaptiveThreshold(deck, bassEnergy);
                const now = this.audioContext.currentTime;
                
                if (bassEnergy > kickThreshold) {
                    this.detectionHistory[deck].push({
                        time: now,
                        bassEnergy,
                        midEnergy,
                        trebleEnergy,
                        totalEnergy: bassEnergy + midEnergy + trebleEnergy
                    });
                    
                    // Garder seulement les 20 derni√®res d√©tections
                    if (this.detectionHistory[deck].length > 20) {
                        this.detectionHistory[deck] = this.detectionHistory[deck].slice(-20);
                    }
                    
                    return this.analyzeBeatPattern(deck);
                }
                
                return null;
            }

            adaptiveThreshold(deck, currentEnergy) {
                const history = this.detectionHistory[deck];
                if (history.length < 5) return 120; // Seuil par d√©faut
                
                const avgEnergy = history.reduce((sum, beat) => sum + beat.bassEnergy, 0) / history.length;
                const variance = history.reduce((sum, beat) => sum + Math.pow(beat.bassEnergy - avgEnergy, 2), 0) / history.length;
                
                return avgEnergy + Math.sqrt(variance) * 0.5; // Seuil adaptatif
            }

            analyzeBeatPattern(deck) {
                const history = this.detectionHistory[deck];
                if (history.length < 8) return null;
                
                // Calculer les intervalles entre beats
                const intervals = [];
                for (let i = 1; i < history.length; i++) {
                    intervals.push(history[i].time - history[i-1].time);
                }
                
                // Filtrer les outliers
                const sortedIntervals = [...intervals].sort((a, b) => a - b);
                const q1 = sortedIntervals[Math.floor(sortedIntervals.length * 0.25)];
                const q3 = sortedIntervals[Math.floor(sortedIntervals.length * 0.75)];
                const iqr = q3 - q1;
                
                const filteredIntervals = intervals.filter(interval => 
                    interval >= q1 - 1.5 * iqr && interval <= q3 + 1.5 * iqr
                );
                
                if (filteredIntervals.length < 4) return null;
                
                const avgInterval = filteredIntervals.reduce((sum, val) => sum + val, 0) / filteredIntervals.length;
                const bpm = Math.round(60 / avgInterval);
                
                // Validation du BPM
                if (bpm < 60 || bpm > 200) return null;
                
                // Calculer la confiance
                const confidence = this.calculateConfidence(filteredIntervals, avgInterval);
                const stability = this.calculateStability(deck, bpm);
                
                // D√©tecter la tonalit√©
                const key = this.detectKey(history);
                this.keyDetection[deck] = key;
                
                return {
                    bpm,
                    confidence: Math.round(confidence * 100),
                    stability: Math.round(stability * 100),
                    key: key,
                    beatPhase: this.calculateBeatPhase(history),
                    energyProfile: this.getEnergyProfile(history)
                };
            }

            calculateConfidence(intervals, avgInterval) {
                const variance = intervals.reduce((sum, val) => sum + Math.pow(val - avgInterval, 2), 0) / intervals.length;
                const stdDev = Math.sqrt(variance);
                return Math.max(0, 1 - (stdDev / avgInterval) * 2);
            }

            calculateStability(deck, currentBpm) {
                if (!this.beatPatterns[deck]) this.beatPatterns[deck] = [];
                
                this.beatPatterns[deck].push(currentBpm);
                if (this.beatPatterns[deck].length > 10) {
                    this.beatPatterns[deck] = this.beatPatterns[deck].slice(-10);
                }
                
                if (this.beatPatterns[deck].length < 5) return 0;
                
                const recentBpms = this.beatPatterns[deck].slice(-5);
                const avgBpm = recentBpms.reduce((sum, val) => sum + val, 0) / recentBpms.length;
                const variance = recentBpms.reduce((sum, val) => sum + Math.pow(val - avgBpm, 2), 0) / recentBpms.length;
                
                this.tempoStability[deck] = Math.max(0, 1 - variance / 100);
                return this.tempoStability[deck];
            }

            detectKey(history) {
                // Analyse harmonique simplifi√©e bas√©e sur l'√©nergie fr√©quentielle
                const energyPattern = history.slice(-8).map(beat => ({
                    bass: beat.bassEnergy,
                    mid: beat.midEnergy,
                    treble: beat.trebleEnergy
                }));
                
                // Patterns de tonalit√© simplifi√©s
                const keyPatterns = {
                    'C': { bass: 0.4, mid: 0.3, treble: 0.3 },
                    'G': { bass: 0.3, mid: 0.4, treble: 0.3 },
                    'D': { bass: 0.35, mid: 0.35, treble: 0.3 },
                    'A': { bass: 0.3, mid: 0.3, treble: 0.4 },
                    'E': { bass: 0.25, mid: 0.35, treble: 0.4 },
                    'F': { bass: 0.45, mid: 0.3, treble: 0.25 }
                };
                
                if (energyPattern.length < 4) return 'Unknown';
                
                const avgPattern = energyPattern.reduce((acc, beat) => ({
                    bass: acc.bass + beat.bass,
                    mid: acc.mid + beat.mid,
                    treble: acc.treble + beat.treble
                }), { bass: 0, mid: 0, treble: 0 });
                
                const total = avgPattern.bass + avgPattern.mid + avgPattern.treble;
                avgPattern.bass /= total;
                avgPattern.mid /= total;
                avgPattern.treble /= total;
                
                let bestMatch = 'Unknown';
                let bestScore = Infinity;
                
                for (const [key, pattern] of Object.entries(keyPatterns)) {
                    const score = Math.abs(pattern.bass - avgPattern.bass) + 
                                 Math.abs(pattern.mid - avgPattern.mid) + 
                                 Math.abs(pattern.treble - avgPattern.treble);
                    
                    if (score < bestScore) {
                        bestScore = score;
                        bestMatch = key;
                    }
                }
                
                return bestScore < 0.3 ? bestMatch : 'Unknown';
            }

            calculateBeatPhase(history) {
                if (history.length < 2) return 0;
                
                const lastBeat = history[history.length - 1];
                const secondLastBeat = history[history.length - 2];
                const interval = lastBeat.time - secondLastBeat.time;
                const timeSinceLastBeat = this.audioContext.currentTime - lastBeat.time;
                
                return (timeSinceLastBeat / interval) % 1;
            }

            getEnergyProfile(history) {
                if (history.length < 4) return 'unknown';
                
                const recent = history.slice(-4);
                const avgEnergy = recent.reduce((sum, beat) => sum + beat.totalEnergy, 0) / recent.length;
                
                if (avgEnergy > 400) return 'high-energy';
                if (avgEnergy > 250) return 'medium-energy';
                return 'low-energy';
            }

            synchronizeDecks(deckA, deckB) {
                if (!deckA.bpm || !deckB.bpm) return null;
                
                const bpmDiff = Math.abs(deckA.bpm - deckB.bpm);
                const keyCompatibility = this.checkKeyCompatibility(deckA.key, deckB.key);
                const energyMatch = this.checkEnergyMatch(deckA.energyProfile, deckB.energyProfile);
                
                // Score de synchronisation global
                const bpmScore = Math.max(0, 100 - (bpmDiff * 3));
                const keyScore = keyCompatibility * 100;
                const energyScore = energyMatch * 100;
                const stabilityScore = (deckA.stability + deckB.stability) / 2;
                
                const overallScore = (bpmScore + keyScore + energyScore + stabilityScore) / 4;
                
                // G√©n√©rer des suggestions intelligentes
                this.generateMixingSuggestions(deckA, deckB, overallScore);
                
                return {
                    syncQuality: Math.round(overallScore),
                    bpmDifference: bpmDiff,
                    keyCompatibility: keyCompatibility,
                    energyMatch: energyMatch,
                    suggestedTempo: this.calculateOptimalTempo(deckA.bpm, deckB.bpm),
                    phaseOffset: (deckA.beatPhase - deckB.beatPhase) % 1,
                    mixingRecommendation: this.getMixingRecommendation(overallScore),
                    transitionTiming: this.getOptimalTransitionTiming(deckA, deckB)
                };
            }

            checkKeyCompatibility(keyA, keyB) {
                const harmonicCircle = {
                    'C': ['F', 'G', 'Am', 'Dm'],
                    'G': ['C', 'D', 'Em', 'Am'],
                    'D': ['G', 'A', 'Bm', 'Em'],
                    'A': ['D', 'E', 'F#m', 'Bm'],
                    'E': ['A', 'B', 'C#m', 'F#m'],
                    'F': ['Bb', 'C', 'Dm', 'Gm']
                };
                
                if (keyA === keyB) return 1.0;
                if (keyA === 'Unknown' || keyB === 'Unknown') return 0.5;
                
                const compatibleKeys = harmonicCircle[keyA] || [];
                return compatibleKeys.includes(keyB) ? 0.8 : 0.3;
            }

            checkEnergyMatch(energyA, energyB) {
                const energyLevels = { 'low-energy': 1, 'medium-energy': 2, 'high-energy': 3 };
                const levelA = energyLevels[energyA] || 2;
                const levelB = energyLevels[energyB] || 2;
                
                const diff = Math.abs(levelA - levelB);
                return Math.max(0, 1 - diff * 0.3);
            }

            calculateOptimalTempo(bpmA, bpmB) {
                const diff = Math.abs(bpmA - bpmB);
                if (diff <= 3) return (bpmA + bpmB) / 2;
                if (diff <= 10) return Math.min(bpmA, bpmB) + diff / 2;
                
                // Doubling/halving pour grands √©carts
                if (Math.abs(bpmA - bpmB * 2) < Math.abs(bpmA - bpmB)) {
                    return (bpmA + bpmB * 2) / 2;
                }
                if (Math.abs(bpmA * 2 - bpmB) < Math.abs(bpmA - bpmB)) {
                    return (bpmA * 2 + bpmB) / 2;
                }
                
                return (bpmA + bpmB) / 2;
            }

            getMixingRecommendation(score) {
                if (score >= 85) return 'Perfect match - mix now!';
                if (score >= 70) return 'Good compatibility - smooth transition';
                if (score >= 50) return 'Moderate sync - adjust tempo';
                if (score >= 30) return 'Challenging mix - consider key change';
                return 'Difficult match - find better transition point';
            }

            getOptimalTransitionTiming(deckA, deckB) {
                const phaseA = deckA.beatPhase;
                const phaseB = deckB.beatPhase;
                
                // Calculer le meilleur moment pour mixer
                const phaseDiff = Math.abs(phaseA - phaseB);
                
                if (phaseDiff < 0.1 || phaseDiff > 0.9) {
                    return 'Mix now - beats aligned!';
                }
                
                const timeToNextBeat = (1 - phaseA) * (60 / deckA.bpm);
                return `Wait ${timeToNextBeat.toFixed(1)}s for beat alignment`;
            }

            generateMixingSuggestions(deckA, deckB, score) {
                this.mixingSuggestions = [];
                
                if (score >= 80) {
                    this.mixingSuggestions.push({
                        type: 'transition',
                        priority: 'high',
                        action: 'Start crossfade - perfect sync detected',
                        confidence: score
                    });
                }
                
                if (Math.abs(deckA.bpm - deckB.bpm) > 5) {
                    this.mixingSuggestions.push({
                        type: 'tempo',
                        priority: 'medium',
                        action: `Adjust tempo: ${deckA.bpm} ‚Üí ${this.calculateOptimalTempo(deckA.bpm, deckB.bpm)}`,
                        confidence: 75
                    });
                }
                
                if (this.checkKeyCompatibility(deckA.key, deckB.key) < 0.5) {
                    this.mixingSuggestions.push({
                        type: 'harmonic',
                        priority: 'low',
                        action: `Key clash detected: ${deckA.key} vs ${deckB.key}`,
                        confidence: 60
                    });
                }
            }

            learnFromMix(mixData) {
                // Machine learning simple pour apprendre les pr√©f√©rences
                this.learningData.push({
                    timestamp: Date.now(),
                    bpmA: mixData.bpmA,
                    bpmB: mixData.bpmB,
                    keyA: mixData.keyA,
                    keyB: mixData.keyB,
                    crossfaderPosition: mixData.crossfaderPosition,
                    mixQuality: mixData.userRating || 5, // Rating par d√©faut
                    transitionType: mixData.transitionType || 'normal'
                });
                
                // Garder seulement les 100 derniers mixes
                if (this.learningData.length > 100) {
                    this.learningData = this.learningData.slice(-100);
                }
            }

            getAIRecommendations() {
                if (this.learningData.length < 10) {
                    return ['Not enough data - keep mixing to improve AI recommendations'];
                }
                
                const recommendations = [];
                
                // Analyser les patterns de BPM pr√©f√©r√©s
                const bpmDiffs = this.learningData.map(mix => Math.abs(mix.bpmA - mix.bpmB));
                const avgBpmDiff = bpmDiffs.reduce((sum, diff) => sum + diff, 0) / bpmDiffs.length;
                
                if (avgBpmDiff < 10) {
                    recommendations.push('You prefer tight BPM matching - current style detected');
                } else {
                    recommendations.push('You like adventurous BPM jumps - creative mixing style');
                }
                
                // Analyser les pr√©f√©rences de tonalit√©
                const keyMixes = this.learningData.filter(mix => mix.keyA !== 'Unknown' && mix.keyB !== 'Unknown');
                if (keyMixes.length > 5) {
                    const harmonicMixes = keyMixes.filter(mix => this.checkKeyCompatibility(mix.keyA, mix.keyB) > 0.7);
                    const harmonicRatio = harmonicMixes.length / keyMixes.length;
                    
                    if (harmonicRatio > 0.7) {
                        recommendations.push('You prefer harmonic mixing - key compatibility prioritized');
                    } else {
                        recommendations.push('You experiment with key clashes - bold mixing approach');
                    }
                }
                
                return recommendations;
            }
        }

        // Real P2P Connection Manager using WebSocket signaling
        class P2PConnectionManager {
            constructor(peerId, onMessage, onConnect, onDisconnect) {
                this.peerId = peerId;
                this.remotePeerId = null;
                this.peerConnection = null;
                this.dataChannel = null;
                this.onMessage = onMessage;
                this.onConnect = onConnect;
                this.onDisconnect = onDisconnect;
                this.isDirectMode = true; // Toujours en mode direct maintenant
                
                // Configuration WebRTC avec serveurs STUN publics
                this.config = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                };
                
                this.initializeSignaling();
            }

            initializeSignaling() {
                // Aller directement en mode P2P local/direct
                console.log('üéØ Initializing Direct P2P mode (skip unreliable WebSocket servers)');
                this.enableDirectP2PMode();
            }

            enableDirectP2PMode() {
                this.updateConnectionStatus('direct-p2p');
                console.log('üéØ Direct P2P mode enabled - manual connection data exchange');
                
                // Marquer comme pr√™t pour les connexions directes
                this.isDirectMode = true;
                
                // Cr√©er une interface pour √©changer manuellement les donn√©es de connexion
                this.createManualConnectionInterface();
            }

            createManualConnectionInterface() {
                const chatMessages = document.getElementById('chat-messages');
                const manualSection = document.createElement('div');
                manualSection.innerHTML = `
                    <div class="chat-message system">
                        üéØ DIRECT P2P MODE: Ready for direct connections
                    </div>
                    <div class="chat-message system">
                        ‚ú® No external servers needed - works 100% reliably
                    </div>
                    <div class="chat-message system">
                        üìã Share your DJ ID and connect directly!
                    </div>
                `;
                chatMessages.appendChild(manualSection);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            handleSignalingDisconnect() {
                this.websocket = null;
                
                if (this.connectionAttempts < this.maxAttempts) {
                    this.connectionAttempts++;
                    console.log(`üîÑ Retrying signaling connection (${this.connectionAttempts}/${this.maxAttempts})`);
                    
                    setTimeout(() => {
                        this.initializeSignaling();
                    }, 2000 * this.connectionAttempts);
                } else {
                    this.updateConnectionStatus('signaling-failed');
                    console.log('‚ùå Max signaling attempts reached, switching to backup mode');
                    this.enableBackupMode();
                }
            }

            handleSignalingError() {
                this.handleSignalingDisconnect();
            }

            enableBackupMode() {
                // Mode de backup avec affichage manuel des offres/r√©ponses
                this.updateConnectionStatus('backup-mode');
                this.showManualConnectionMode();
            }

            showManualConnectionMode() {
                const chatMessages = document.getElementById('chat-messages');
                chatMessages.innerHTML += `
                    <div class="chat-message system">
                        üîß BACKUP MODE: Copy/paste connection data manually with your DJ partner
                    </div>
                `;
            }

            async initializeConnection(remotePeerId) {
                this.remotePeerId = remotePeerId;
                this.peerConnection = new RTCPeerConnection(this.config);
                this.pendingIceCandidates = []; // Queue pour les ICE candidates
                
                // Setup event handlers
                this.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.sendSignalingMessage({
                            type: 'ice-candidate',
                            candidate: event.candidate,
                            from: this.peerId,
                            to: remotePeerId
                        });
                    }
                };
                
                this.peerConnection.onconnectionstatechange = () => {
                    const state = this.peerConnection.connectionState;
                    console.log('üîÑ Connection state:', state);
                    this.updateConnectionStatus(state);
                    
                    if (state === 'connected') {
                        this.onConnect();
                    } else if (state === 'disconnected' || state === 'failed') {
                        this.onDisconnect();
                    }
                };
                
                // Create data channel
                this.dataChannel = this.peerConnection.createDataChannel('neuralmix', {
                    ordered: true
                });
                
                this.dataChannel.onopen = () => {
                    console.log('üéµ Data channel opened');
                    this.sendMessage({ type: 'hello', peerId: this.peerId });
                    
                    // Ajouter message dans le chat
                    const chatMessages = document.getElementById('chat-messages');
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'chat-message system';
                    messageDiv.innerHTML = `<span style="color: #22c55e;">‚úÖ P2P data channel established</span>`;
                    chatMessages.appendChild(messageDiv);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                };
                
                this.dataChannel.onclose = () => {
                    console.log('‚ùå Data channel closed');
                    const chatMessages = document.getElementById('chat-messages');
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'chat-message system';
                    messageDiv.innerHTML = `<span style="color: #ef4444;">‚ùå P2P data channel closed</span>`;
                    chatMessages.appendChild(messageDiv);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                };
                
                this.dataChannel.onerror = (error) => {
                    console.log('üö® Data channel error:', error);
                };
                
                this.dataChannel.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.onMessage(data);
                };
                
                // Handle incoming data channels
                this.peerConnection.ondatachannel = (event) => {
                    const channel = event.channel;
                    channel.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.onMessage(data);
                    };
                };
                
                return this.peerConnection;
            }

            async createOffer() {
                const offer = await this.peerConnection.createOffer();
                await this.peerConnection.setLocalDescription(offer);
                
                this.sendSignalingMessage({
                    type: 'offer',
                    offer: offer,
                    from: this.peerId,
                    to: this.remotePeerId
                });
            }

            async handleOffer(offer, fromPeerId) {
                this.remotePeerId = fromPeerId;
                
                if (!this.peerConnection) {
                    await this.initializeConnection(fromPeerId);
                }
                
                try {
                    await this.peerConnection.setRemoteDescription(offer);
                    console.log('‚úÖ Remote description set from offer');
                    
                    // Traiter les ICE candidates en attente
                    await this.processPendingIceCandidates();
                    
                    const answer = await this.peerConnection.createAnswer();
                    await this.peerConnection.setLocalDescription(answer);
                    
                    this.sendSignalingMessage({
                        type: 'answer',
                        answer: answer,
                        from: this.peerId,
                        to: fromPeerId
                    });
                } catch (error) {
                    console.error('‚ùå Error handling offer:', error);
                }
            }

            async handleAnswer(answer) {
                try {
                    await this.peerConnection.setRemoteDescription(answer);
                    console.log('‚úÖ Remote description set from answer');
                    
                    // Traiter les ICE candidates en attente
                    await this.processPendingIceCandidates();
                } catch (error) {
                    console.error('‚ùå Error handling answer:', error);
                }
            }

            async handleIceCandidate(candidate) {
                if (this.peerConnection) {
                    if (this.peerConnection.remoteDescription) {
                        try {
                            await this.peerConnection.addIceCandidate(candidate);
                            console.log('‚úÖ ICE candidate added');
                        } catch (error) {
                            console.log('‚ö†Ô∏è Failed to add ICE candidate:', error.message);
                        }
                    } else {
                        // Queue les ICE candidates si pas de remote description
                        console.log('üìã Queueing ICE candidate (no remote description yet)');
                        this.pendingIceCandidates.push(candidate);
                    }
                }
            }

            async processPendingIceCandidates() {
                if (this.pendingIceCandidates && this.pendingIceCandidates.length > 0) {
                    console.log(`üîÑ Processing ${this.pendingIceCandidates.length} pending ICE candidates`);
                    
                    for (const candidate of this.pendingIceCandidates) {
                        try {
                            await this.peerConnection.addIceCandidate(candidate);
                        } catch (error) {
                            console.log('‚ö†Ô∏è Failed to add queued ICE candidate:', error.message);
                        }
                    }
                    
                    this.pendingIceCandidates = [];
                }
            }

            sendMessage(data) {
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    try {
                        this.dataChannel.send(JSON.stringify(data));
                        // Ne logger que les messages importants, pas le spam crossfader
                        if (data.type !== 'crossfader') {
                            console.log('üì§ P2P message sent:', data.type);
                        }
                        return true;
                    } catch (error) {
                        console.error('‚ùå Failed to send P2P message:', error);
                        return false;
                    }
                } else {
                    console.log('‚ö†Ô∏è Data channel not ready:', {
                        exists: !!this.dataChannel,
                        state: this.dataChannel?.readyState || 'null'
                    });
                    return false;
                }
            }

            sendSignalingMessage(message) {
                // En mode direct, utiliser localStorage comme relai temporaire
                if (this.isDirectMode) {
                    const key = `neuralmix-direct-${message.to || 'broadcast'}`;
                    const existingMessages = JSON.parse(localStorage.getItem(key) || '[]');
                    existingMessages.push({
                        ...message,
                        timestamp: Date.now()
                    });
                    
                    // Garder seulement les 10 derniers messages
                    if (existingMessages.length > 10) {
                        existingMessages.splice(0, existingMessages.length - 10);
                    }
                    
                    localStorage.setItem(key, JSON.stringify(existingMessages));
                    console.log('üì§ Direct P2P message queued:', message.type);
                    return true;
                }
                
                // Mode WebSocket (non utilis√© maintenant)
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify(message));
                    return true;
                } else {
                    console.log('üì§ Signaling not available, using direct mode');
                    return false;
                }
            }

            checkDirectMessages() {
                if (!this.isDirectMode) return;
                
                try {
                    const key = `neuralmix-direct-${this.peerId}`;
                    const messages = JSON.parse(localStorage.getItem(key) || '[]');
                    
                    if (messages.length > 0) {
                        messages.forEach(message => {
                            this.handleSignalingMessage(message);
                        });
                        
                        // Nettoyer les messages trait√©s
                        localStorage.removeItem(key);
                    }
                } catch (error) {
                    console.error('Error checking direct messages:', error);
                }
            }

            async handleSignalingMessage(data) {
                // Ignorer les messages qui ne nous sont pas destin√©s
                if (data.to && data.to !== this.peerId) {
                    return;
                }
                
                try {
                    switch (data.type) {
                        case 'offer':
                            console.log('üì• Received offer from:', data.from);
                            await this.handleOffer(data.offer, data.from);
                            break;
                        case 'answer':
                            console.log('üì• Received answer from:', data.from);
                            await this.handleAnswer(data.answer);
                            break;
                        case 'ice-candidate':
                            await this.handleIceCandidate(data.candidate);
                            break;
                        case 'register':
                            // Autre peer s'est enregistr√©
                            break;
                        default:
                            console.log('Unknown signaling message:', data.type);
                    }
                } catch (error) {
                    console.error('Error handling signaling message:', error);
                }
            }

            updateConnectionStatus(state) {
                const statusIndicator = document.querySelector('.status-indicator');
                const statusText = document.getElementById('status-text');
                
                if (!statusIndicator || !statusText) return;
                
                statusIndicator.className = 'status-indicator';
                
                switch (state) {
                    case 'connected':
                        statusIndicator.classList.add('status-connected');
                        statusText.textContent = 'P2P Connected üî•';
                        break;
                    case 'connecting':
                        statusIndicator.classList.add('status-connecting');
                        statusText.textContent = 'Connecting...';
                        break;
                    case 'direct-p2p':
                        statusIndicator.classList.add('status-connecting');
                        statusText.textContent = 'Direct P2P Ready ‚ö°';
                        break;
                    default:
                        statusIndicator.classList.add('status-disconnected');
                        statusText.textContent = 'Ready to Connect';
                        break;
                }
            }
            }
            }

            disconnect() {
                if (this.dataChannel) {
                    this.dataChannel.close();
                    this.dataChannel = null;
                }
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                
                this.updateConnectionStatus('direct-p2p');
                this.onDisconnect();
            }
        }

        // Audio Engine
        class AudioEngine {
            constructor() {
                this.audioContext = null;
                this.masterGainNode = null;
                this.crossfaderGainA = null;
                this.crossfaderGainB = null;
            }

            async initialize() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Master output chain
                this.masterGainNode = this.audioContext.createGain();
                this.masterGainNode.connect(this.audioContext.destination);
                
                // Crossfader gains
                this.crossfaderGainA = this.audioContext.createGain();
                this.crossfaderGainB = this.audioContext.createGain();
                
                this.crossfaderGainA.connect(this.masterGainNode);
                this.crossfaderGainB.connect(this.masterGainNode);
                
                console.log('üéµ Audio engine initialized');
                return this.audioContext;
            }

            createDeckChain(deck) {
                const deckData = {
                    gainNode: this.audioContext.createGain(),
                    eqNodes: {
                        high: this.audioContext.createBiquadFilter(),
                        mid: this.audioContext.createBiquadFilter(),
                        low: this.audioContext.createBiquadFilter()
                    },
                    analyser: this.audioContext.createAnalyser()
                };
                
                // Configure EQ filters
                deckData.eqNodes.high.type = 'highshelf';
                deckData.eqNodes.high.frequency.value = 3200;
                deckData.eqNodes.mid.type = 'peaking';
                deckData.eqNodes.mid.frequency.value = 1000;
                deckData.eqNodes.mid.Q.value = 1;
                deckData.eqNodes.low.type = 'lowshelf';
                deckData.eqNodes.low.frequency.value = 320;
                
                // Configure analyser
                deckData.analyser.fftSize = 2048;
                
                // Connect chain: gain -> EQ -> analyser -> crossfader
                deckData.gainNode.connect(deckData.eqNodes.high);
                deckData.eqNodes.high.connect(deckData.eqNodes.mid);
                deckData.eqNodes.mid.connect(deckData.eqNodes.low);
                deckData.eqNodes.low.connect(deckData.analyser);
                
                if (deck === 'a') {
                    deckData.analyser.connect(this.crossfaderGainA);
                } else {
                    deckData.analyser.connect(this.crossfaderGainB);
                }
                
                return deckData;
            }

            async loadAudioFile(file, deck) {
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                return audioBuffer;
            }

            updateCrossfader(position) {
                // Position: 0 = full A, 1 = full B
                const gainA = Math.cos(position * Math.PI / 2);
                const gainB = Math.sin(position * Math.PI / 2);
                
                this.crossfaderGainA.gain.value = gainA;
                this.crossfaderGainB.gain.value = gainB;
            }
        }

        // Waveform Visualizer
        class WaveformVisualizer {
            constructor(canvas, audioBuffer = null) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.audioBuffer = audioBuffer;
                this.animationId = null;
                
                this.setupCanvas();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            drawWaveform(audioBuffer) {
                if (!audioBuffer) return;
                
                this.audioBuffer = audioBuffer;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.clearRect(0, 0, width, height);
                
                // Get audio data
                const channelData = audioBuffer.getChannelData(0);
                const samples = channelData.length;
                const samplesPerPixel = Math.floor(samples / width);
                
                // Draw waveform
                this.ctx.strokeStyle = '#a855f7';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                
                for (let x = 0; x < width; x++) {
                    const start = x * samplesPerPixel;
                    const end = start + samplesPerPixel;
                    
                    let min = 1, max = -1;
                    for (let i = start; i < end && i < samples; i++) {
                        const sample = channelData[i];
                        if (sample < min) min = sample;
                        if (sample > max) max = sample;
                    }
                    
                    const yMin = (min + 1) * height / 2;
                    const yMax = (max + 1) * height / 2;
                    
                    if (x === 0) {
                        this.ctx.moveTo(x, yMin);
                    }
                    
                    this.ctx.lineTo(x, yMin);
                    this.ctx.lineTo(x, yMax);
                }
                
                this.ctx.stroke();
            }

            drawSpectrum(analyserNode) {
                if (!analyserNode) return;
                
                const bufferLength = analyserNode.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyserNode.getByteFrequencyData(dataArray);
                
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.clearRect(0, 0, width, height);
                
                const barWidth = width / bufferLength * 2;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * height;
                    
                    const hue = (i / bufferLength) * 360;
                    this.ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                    this.ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                    
                    x += barWidth + 1;
                }
            }
        }

        // Main Application
        class NeuralMixApp {
            constructor() {
                this.state = new NeuralMixState();
                this.audioEngine = new AudioEngine();
                this.beatDetector = null;
                this.p2pManager = null;
                this.waveformVisualizers = {};
                this.spectralVisualizer = null;
                
                this.init();
            }

            async init() {
                console.log('üéß Initializing NeuralMix P2P...');
                
                // Initialize audio engine
                await this.audioEngine.initialize();
                this.beatDetector = new NeuralBeatDetector(this.audioEngine.audioContext);
                
                // Setup UI elements
                this.setupUI();
                this.setupEventListeners();
                this.setupVisualizers();
                
                // Request notification permission
                this.requestNotificationPermission();
                
                // Initialize P2P manager
                this.initializeP2P();
                
                // Start update loops
                this.startUpdateLoops();
                
                console.log('üöÄ NeuralMix P2P ready!');
                this.addChatMessage('üéµ NeuralMix P2P initialized', 'system');
                this.addChatMessage('üéØ Direct P2P mode active (no external servers needed)', 'system');
                this.addChatMessage('üì° Ready for direct DJ connections', 'system');
                this.addChatMessage('üí¨ Chat ready - click üß™ to test', 'system');
            }

            setupUI() {
                document.getElementById('peer-id').value = this.state.peerId;
                
                // Setup deck audio chains
                this.state.decks.a = { ...this.state.decks.a, ...this.audioEngine.createDeckChain('a') };
                this.state.decks.b = { ...this.state.decks.b, ...this.audioEngine.createDeckChain('b') };
            }

            setupEventListeners() {
                // File uploads
                document.getElementById('file-a').addEventListener('change', (e) => this.loadTrack('a', e.target.files[0]));
                document.getElementById('file-b').addEventListener('change', (e) => this.loadTrack('b', e.target.files[0]));
                
                // Play buttons
                document.getElementById('play-a').addEventListener('click', () => this.togglePlay('a'));
                document.getElementById('play-b').addEventListener('click', () => this.togglePlay('b'));
                
                // P2P connection
                document.getElementById('copy-id-btn').addEventListener('click', () => this.copyPeerId());
                document.getElementById('connect-btn').addEventListener('click', () => this.connectToPeer());
                
                // Chat
                document.getElementById('send-chat-btn').addEventListener('click', () => this.sendChatMessage());
                document.getElementById('test-chat-btn').addEventListener('click', () => this.testChat());
                document.getElementById('chat-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.sendChatMessage();
                    }
                });
                
                // Crossfader
                this.setupCrossfader();
                
                // Control sliders
                this.setupControlSliders();
            }

            setupCrossfader() {
                const crossfader = document.getElementById('crossfader');
                const handle = document.getElementById('crossfader-handle');
                let isDragging = false;
                let lastSentPosition = -1; // Pour √©viter le spam
                
                const updateCrossfader = (e) => {
                    const rect = crossfader.getBoundingClientRect();
                    const x = Math.max(0, Math.min(rect.width - 50, e.clientX - rect.left - 25));
                    const position = x / (rect.width - 50);
                    
                    handle.style.left = `${x}px`;
                    this.state.mixer.crossfaderPosition = position;
                    this.audioEngine.updateCrossfader(position);
                    
                    // Envoyer seulement si la position a vraiment chang√© (√©viter le spam)
                    const roundedPosition = Math.round(position * 100) / 100; // Arrondir √† 2 d√©cimales
                    if (this.p2pManager && Math.abs(roundedPosition - lastSentPosition) > 0.01) {
                        console.log('üì§ Sending crossfader position:', roundedPosition);
                        
                        const success = this.p2pManager.sendMessage({
                            type: 'crossfader',
                            position: roundedPosition
                        });
                        
                        if (success) {
                            lastSentPosition = roundedPosition;
                            console.log('‚úÖ Crossfader message sent successfully');
                        } else {
                            console.log('‚ùå Failed to send crossfader message');
                        }
                    }
                };
                
                handle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    console.log('üéöÔ∏è Started dragging crossfader');
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) updateCrossfader(e);
                });
                
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        console.log('üéöÔ∏è Stopped dragging crossfader');
                        isDragging = false;
                    }
                });
                
                crossfader.addEventListener('click', (e) => {
                    console.log('üéöÔ∏è Crossfader clicked');
                    updateCrossfader(e);
                });
            }

            setupControlSliders() {
                const sliders = document.querySelectorAll('.control-slider');
                
                sliders.forEach(slider => {
                    let isDragging = false;
                    const handle = slider.querySelector('.slider-handle');
                    const deck = slider.dataset.deck;
                    const control = slider.dataset.control;
                    
                    const updateSlider = (e) => {
                        const rect = slider.getBoundingClientRect();
                        const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
                        const position = x / rect.width;
                        
                        handle.style.left = `${position * 100}%`;
                        this.updateControl(deck, control, position);
                    };
                    
                    slider.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        updateSlider(e);
                        e.preventDefault();
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (isDragging) updateSlider(e);
                    });
                    
                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                });
            }

            updateControl(deck, control, position) {
                const deckData = this.state.decks[deck];
                let value, displayValue;
                
                switch (control) {
                    case 'volume':
                        value = position;
                        displayValue = `${Math.round(position * 100)}%`;
                        deckData.gainNode.gain.value = value;
                        break;
                        
                    case 'high':
                    case 'mid':
                    case 'low':
                        value = (position - 0.5) * 40; // -20dB to +20dB
                        displayValue = `${value > 0 ? '+' : ''}${value.toFixed(1)}dB`;
                        deckData.eqNodes[control].gain.value = value;
                        break;
                }
                
                document.getElementById(`${control}-${deck}-value`).textContent = displayValue;
                
                // Throttle les messages P2P pour √©viter le spam
                if (!this.controlThrottles) this.controlThrottles = {};
                const key = `${deck}-${control}`;
                
                if (this.controlThrottles[key]) {
                    clearTimeout(this.controlThrottles[key]);
                }
                
                this.controlThrottles[key] = setTimeout(() => {
                    // Send to peer
                    if (this.p2pManager) {
                        this.p2pManager.sendMessage({
                            type: 'control',
                            deck: deck,
                            control: control,
                            value: position
                        });
                    }
                    delete this.controlThrottles[key];
                }, 100); // Envoyer max 1 fois par 100ms
            }

            setupVisualizers() {
                // Waveform visualizers
                this.waveformVisualizers.a = new WaveformVisualizer(document.getElementById('waveform-a'));
                this.waveformVisualizers.b = new WaveformVisualizer(document.getElementById('waveform-b'));
                
                // Spectral visualizer
                this.spectralVisualizer = new WaveformVisualizer(document.getElementById('spectral-canvas'));
            }

            async loadTrack(deck, file) {
                if (!file) return;
                
                try {
                    const audioBuffer = await this.audioEngine.loadAudioFile(file, deck);
                    this.state.decks[deck].buffer = audioBuffer;
                    
                    // Draw waveform
                    this.waveformVisualizers[deck].drawWaveform(audioBuffer);
                    
                    // Update deck status
                    document.getElementById(`deck-${deck}-status`).textContent = 'LOADED';
                    
                    this.addChatMessage(`üéµ Track loaded on Deck ${deck.toUpperCase()}: ${file.name}`, 'system');
                    
                    // Send to peer
                    if (this.p2pManager) {
                        this.p2pManager.sendMessage({
                            type: 'track-loaded',
                            deck: deck,
                            filename: file.name
                        });
                    }
                    
                } catch (error) {
                    console.error('Error loading track:', error);
                    this.addChatMessage(`‚ùå Error loading track: ${error.message}`, 'system');
                }
            }

            togglePlay(deck) {
                const deckData = this.state.decks[deck];
                const button = document.getElementById(`play-${deck}`);
                
                if (deckData.isPlaying) {
                    // Stop
                    if (deckData.source) {
                        deckData.source.stop();
                        deckData.source = null;
                    }
                    deckData.isPlaying = false;
                    button.textContent = '‚ñ∂';
                    button.classList.remove('playing');
                    document.getElementById(`deck-${deck}-status`).textContent = 'STOPPED';
                } else {
                    // Play
                    if (deckData.buffer) {
                        deckData.source = this.audioEngine.audioContext.createBufferSource();
                        deckData.source.buffer = deckData.buffer;
                        deckData.source.loop = true;
                        deckData.source.connect(deckData.gainNode);
                        deckData.source.start();
                        
                        deckData.isPlaying = true;
                        button.textContent = '‚è∏';
                        button.classList.add('playing');
                        document.getElementById(`deck-${deck}-status`).textContent = 'PLAYING';
                    }
                }
                
                // Send to peer
                if (this.p2pManager) {
                    this.p2pManager.sendMessage({
                        type: 'play-state',
                        deck: deck,
                        isPlaying: deckData.isPlaying
                    });
                }
            }

            initializeP2P() {
                this.p2pManager = new P2PConnectionManager(
                    this.state.peerId,
                    (message) => this.handleP2PMessage(message),
                    () => this.handleP2PConnect(),
                    () => this.handleP2PDisconnect()
                );
                
                // V√©rifier les messages directs p√©riodiquement (mode direct seulement)
                setInterval(() => {
                    if (this.p2pManager && this.p2pManager.isDirectMode) {
                        this.p2pManager.checkDirectMessages();
                    }
                }, 2000);
                
                console.log('üåê P2P Manager initialized in Direct Mode');
            }

            async connectToPeer() {
                const remotePeerId = document.getElementById('remote-peer-id').value.trim();
                if (!remotePeerId) {
                    this.addChatMessage('‚ùå Please enter a DJ ID', 'system');
                    return;
                }
                
                if (remotePeerId === this.state.peerId) {
                    this.addChatMessage('‚ùå Cannot connect to yourself', 'system');
                    return;
                }
                
                try {
                    this.addChatMessage(`üìû Initiating P2P connection to: ${remotePeerId}`, 'system');
                    this.addChatMessage('üåê Using WebRTC with real signaling server', 'system');
                    
                    await this.p2pManager.initializeConnection(remotePeerId);
                    await this.p2pManager.createOffer();
                    
                    this.addChatMessage(`üì° Connection offer sent - waiting for response...`, 'system');
                } catch (error) {
                    console.error('Connection error:', error);
                    this.addChatMessage(`‚ùå Connection failed: ${error.message}`, 'system');
                    this.addChatMessage('üí° Try: 1) Check internet 2) Verify DJ ID 3) Both click connect', 'system');
                }
            }

            handleP2PMessage(message) {
                switch (message.type) {
                    case 'hello':
                        this.addChatMessage(`üëã Connected to DJ: ${message.peerId}`, 'system');
                        break;
                        
                    case 'crossfader':
                        console.log('üì° Received crossfader position:', message.position);
                        this.updateRemoteCrossfader(message.position);
                        break;
                        
                    case 'control':
                        console.log('üì° Received control update:', message.deck, message.control, message.value);
                        this.updateRemoteControl(message.deck, message.control, message.value);
                        break;
                        
                    case 'play-state':
                        this.updateRemotePlayState(message.deck, message.isPlaying);
                        break;
                        
                    case 'chat':
                        const time = new Date(message.timestamp || Date.now()).toLocaleTimeString();
                        this.addChatMessage(`üéß Remote DJ [${time}]: ${message.text}`, 'peer');
                        
                        // Notification sonore ou visuelle
                        if ('Notification' in window && Notification.permission === 'granted') {
                            new Notification('NeuralMix Chat', {
                                body: `Remote DJ: ${message.text}`,
                                icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%2322d3ee"/><text x="50" y="60" text-anchor="middle" fill="white" font-size="25">üí¨</text></svg>'
                            });
                        }
                        break;
                        
                    case 'track-loaded':
                        this.addChatMessage(`üéµ Remote DJ loaded: ${message.filename} on Deck ${message.deck.toUpperCase()}`, 'peer');
                        break;
                        
                    default:
                        console.log('ü§∑ Unknown P2P message type:', message.type);
                }
            }

            handleP2PConnect() {
                this.state.isConnected = true;
                this.addChatMessage('üî• P2P connection established! Ready to mix!', 'system');
                
                // Show browser notification
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification('NeuralMix P2P Connected!', {
                        body: 'Your DJ session is now live with real-time collaboration',
                        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%23a855f7"/><text x="50" y="60" text-anchor="middle" fill="white" font-size="25">üéß</text></svg>'
                    });
                }
            }

            handleP2PDisconnect() {
                this.state.isConnected = false;
                this.addChatMessage('‚ö†Ô∏è P2P connection lost - checking reconnection', 'system');
                
                // Tenter une reconnexion automatique
                setTimeout(() => {
                    if (!this.state.isConnected && this.p2pManager) {
                        this.addChatMessage('üîÑ Attempting automatic reconnection...', 'system');
                    }
                }, 3000);
            }

            updateRemoteCrossfader(position) {
                console.log('üéöÔ∏è Updating crossfader to position:', position);
                
                const handle = document.getElementById('crossfader-handle');
                const crossfader = document.getElementById('crossfader');
                
                if (!handle || !crossfader) {
                    console.log('‚ùå Crossfader elements not found');
                    return;
                }
                
                const rect = crossfader.getBoundingClientRect();
                const x = position * (rect.width - 50);
                
                // Mettre √† jour visuellement
                handle.style.left = `${x}px`;
                
                // Mettre √† jour l'√©tat interne
                this.state.mixer.crossfaderPosition = position;
                
                // Appliquer l'audio crossfading
                this.audioEngine.updateCrossfader(position);
                
                console.log('‚úÖ Crossfader updated - Position:', position, 'Visual X:', x);
                
                // Ajouter un indicateur visuel temporaire qu'on re√ßoit une mise √† jour
                this.showCrossfaderSync();
            }

            showCrossfaderSync() {
                const handle = document.getElementById('crossfader-handle');
                if (handle) {
                    // Flash visuel pour montrer la synchronisation
                    handle.style.boxShadow = '0 0 15px #22d3ee';
                    setTimeout(() => {
                        handle.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.3)';
                    }, 200);
                }
            }

            updateRemoteControl(deck, control, position) {
                // Update UI
                const slider = document.querySelector(`[data-deck="${deck}"][data-control="${control}"]`);
                const handle = slider.querySelector('.slider-handle');
                handle.style.left = `${position * 100}%`;
                
                // Update audio
                this.updateControl(deck, control, position);
            }

            updateRemotePlayState(deck, isPlaying) {
                const button = document.getElementById(`play-${deck}`);
                const deckData = this.state.decks[deck];
                
                if (isPlaying && !deckData.isPlaying) {
                    button.textContent = '‚è∏';
                    button.classList.add('playing');
                    document.getElementById(`deck-${deck}-status`).textContent = 'REMOTE PLAYING';
                } else if (!isPlaying && deckData.isPlaying) {
                    button.textContent = '‚ñ∂';
                    button.classList.remove('playing');
                    document.getElementById(`deck-${deck}-status`).textContent = 'REMOTE STOPPED';
                }
            }

            requestNotificationPermission() {
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            this.addChatMessage('üîî Notifications enabled for P2P events', 'system');
                        }
                    });
                }
            }

            copyPeerId() {
                navigator.clipboard.writeText(this.state.peerId).then(() => {
                    this.addChatMessage('üìã DJ ID copied to clipboard', 'system');
                }).catch(() => {
                    this.addChatMessage('‚ùå Failed to copy DJ ID', 'system');
                });
            }

            testChat() {
                const testMessages = [
                    "üß™ Chat test message",
                    "üéµ Ready to mix?",
                    "üî• This beat is fire!",
                    "üéß Sync check 1-2-3"
                ];
                
                const randomMessage = testMessages[Math.floor(Math.random() * testMessages.length)];
                this.addChatMessage(`[TEST] ${randomMessage}`, 'system');
                this.addChatMessage(`‚úÖ Chat interface working!`, 'system');
                
                // Test du data channel si connect√©
                if (this.state.isConnected && this.p2pManager) {
                    console.log('üß™ Testing P2P message sending...');
                    
                    const success = this.p2pManager.sendMessage({
                        type: 'chat',
                        text: randomMessage + " (test from P2P)",
                        timestamp: Date.now()
                    });
                    
                    this.addChatMessage(`üì° P2P test sent: ${success ? 'SUCCESS' : 'FAILED'}`, 'system');
                    
                    // Test aussi le crossfader
                    const testPosition = Math.random();
                    console.log('üß™ Testing crossfader sync with position:', testPosition);
                    
                    const crossfaderSuccess = this.p2pManager.sendMessage({
                        type: 'crossfader',
                        position: testPosition
                    });
                    
                    this.addChatMessage(`üéöÔ∏è Crossfader test sent: ${crossfaderSuccess ? 'SUCCESS' : 'FAILED'}`, 'system');
                    
                } else {
                    this.addChatMessage(`‚ö†Ô∏è P2P not connected - local test only`, 'system');
                    this.addChatMessage(`üîó Connect with another DJ to test crossfader sync`, 'system');
                }
            }

            sendChatMessage() {
                const input = document.getElementById('chat-input');
                const text = input.value.trim();
                
                if (!text) {
                    return;
                }
                
                if (this.state.isConnected && this.p2pManager) {
                    const success = this.p2pManager.sendMessage({
                        type: 'chat',
                        text: text,
                        timestamp: Date.now()
                    });
                    
                    if (success) {
                        this.addChatMessage(`You: ${text}`, 'local');
                        input.value = '';
                    } else {
                        this.addChatMessage(`‚ùå Message failed - P2P not connected`, 'system');
                    }
                } else {
                    // Mode local - juste pour tester l'interface
                    this.addChatMessage(`[LOCAL] You: ${text}`, 'local');
                    this.addChatMessage(`ü§ñ Echo: ${text}`, 'system');
                    input.value = '';
                }
            }

            addChatMessage(text, type) {
                const chatMessages = document.getElementById('chat-messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${type}`;
                
                const time = new Date().toLocaleTimeString();
                messageDiv.innerHTML = `<span style="color: #6b7280;">[${time}]</span> ${text}`;
                
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            startUpdateLoops() {
                // Neural analysis loop
                const neuralUpdate = () => {
                    this.updateNeuralAnalysis();
                    requestAnimationFrame(neuralUpdate);
                };
                neuralUpdate();
                
                // Spectral visualization loop
                const spectralUpdate = () => {
                    this.updateSpectralDisplay();
                    requestAnimationFrame(spectralUpdate);
                };
                spectralUpdate();
            }

            updateNeuralAnalysis() {
                let analysisResults = { a: null, b: null };
                let totalConfidence = 0;
                let syncedDecks = 0;
                
                ['a', 'b'].forEach(deck => {
                    const deckData = this.state.decks[deck];
                    if (deckData.isPlaying && deckData.analyser) {
                        const beatData = this.beatDetector.detectBPM(deckData.analyser, deck);
                        if (beatData) {
                            deckData.bpm = beatData.bpm;
                            deckData.confidence = beatData.confidence;
                            deckData.stability = beatData.stability;
                            deckData.key = beatData.key;
                            deckData.beatPhase = beatData.beatPhase;
                            deckData.energyProfile = beatData.energyProfile;
                            
                            analysisResults[deck] = beatData;
                            totalConfidence += beatData.confidence;
                            syncedDecks++;
                        }
                    }
                });
                
                // Update neural sync display
                if (syncedDecks > 0) {
                    const avgConfidence = totalConfidence / syncedDecks;
                    this.state.neural.confidence = avgConfidence;
                    
                    // Synchronisation intelligente entre decks
                    const syncData = this.beatDetector.synchronizeDecks(
                        analysisResults.a || this.state.decks.a,
                        analysisResults.b || this.state.decks.b
                    );
                    
                    if (syncData) {
                        // Mise √† jour affichage principal
                        const bpmDisplayA = analysisResults.a ? `${analysisResults.a.bpm}` : '--';
                        const bpmDisplayB = analysisResults.b ? `${analysisResults.b.bpm}` : '--';
                        const keyDisplayA = analysisResults.a ? `(${analysisResults.a.key})` : '';
                        const keyDisplayB = analysisResults.b ? `(${analysisResults.b.key})` : '';
                        
                        document.getElementById('bpm-sync').textContent = `${bpmDisplayA}${keyDisplayA} / ${bpmDisplayB}${keyDisplayB}`;
                        document.getElementById('beat-align').textContent = `${syncData.syncQuality}%`;
                        document.getElementById('neural-confidence').textContent = `${Math.round(avgConfidence)}%`;
                        
                        // Mise √† jour couleur bas√©e sur la qualit√© de sync
                        const bpmElement = document.getElementById('bpm-sync');
                        const alignElement = document.getElementById('beat-align');
                        const confidenceElement = document.getElementById('neural-confidence');
                        
                        if (syncData.syncQuality >= 80) {
                            alignElement.style.color = '#22c55e'; // Vert
                        } else if (syncData.syncQuality >= 60) {
                            alignElement.style.color = '#eab308'; // Jaune
                        } else {
                            alignElement.style.color = '#ef4444'; // Rouge
                        }
                        
                        if (avgConfidence >= 75) {
                            confidenceElement.style.color = '#22c55e';
                        } else if (avgConfidence >= 50) {
                            confidenceElement.style.color = '#eab308';
                        } else {
                            confidenceElement.style.color = '#ef4444';
                        }
                        
                        // Afficher les recommandations IA
                        this.updateAIRecommendations(syncData);
                        
                        // Apprendre du mix en cours
                        if (this.state.isConnected && syncData.syncQuality > 70) {
                            this.beatDetector.learnFromMix({
                                bpmA: analysisResults.a?.bpm,
                                bpmB: analysisResults.b?.bpm,
                                keyA: analysisResults.a?.key,
                                keyB: analysisResults.b?.key,
                                crossfaderPosition: this.state.mixer.crossfaderPosition,
                                transitionType: this.detectTransitionType()
                            });
                        }
                    }
                }
                
                // Envoyer les donn√©es neural au peer
                if (this.p2pManager && this.state.isConnected && syncedDecks > 0) {
                    this.p2pManager.sendMessage({
                        type: 'neural-data',
                        analysis: {
                            deckA: analysisResults.a,
                            deckB: analysisResults.b,
                            confidence: this.state.neural.confidence,
                            timestamp: Date.now()
                        }
                    });
                }
            }

            updateAIRecommendations(syncData) {
                // Suggestions intelligentes en temps r√©el
                const suggestions = [];
                
                if (syncData.mixingRecommendation) {
                    suggestions.push(`üéØ ${syncData.mixingRecommendation}`);
                }
                
                if (syncData.transitionTiming && syncData.transitionTiming.includes('Wait')) {
                    suggestions.push(`‚è∞ ${syncData.transitionTiming}`);
                }
                
                if (syncData.bpmDifference > 10) {
                    suggestions.push(`üéµ Large BPM gap: ${syncData.bpmDifference} BPM difference`);
                }
                
                if (syncData.keyCompatibility < 0.5) {
                    suggestions.push(`üéº Key clash detected - consider harmonic mixing`);
                }
                
                // Afficher dans le chat si importantes
                if (suggestions.length > 0 && Math.random() < 0.1) { // 10% chance d'afficher
                    const randomSuggestion = suggestions[Math.floor(Math.random() * suggestions.length)];
                    this.addChatMessage(`üß† AI Suggestion: ${randomSuggestion}`, 'system');
                }
                
                // Stocker pour l'affichage permanent
                this.currentAISuggestions = suggestions;
            }

            detectTransitionType() {
                const crossfaderPos = this.state.mixer.crossfaderPosition;
                
                if (crossfaderPos < 0.2) return 'deck-a-dominant';
                if (crossfaderPos > 0.8) return 'deck-b-dominant';
                if (crossfaderPos > 0.4 && crossfaderPos < 0.6) return 'balanced-mix';
                return 'transitioning';
            }

            showNeuralInsights() {
                // Affichage p√©riodique des insights IA
                const insights = this.beatDetector.getAIRecommendations();
                
                if (insights.length > 0 && Date.now() % 30000 < 1000) { // Chaque 30 secondes
                    const randomInsight = insights[Math.floor(Math.random() * insights.length)];
                    this.addChatMessage(`ü§ñ Neural Insight: ${randomInsight}`, 'system');
                }
            }

            updateSpectralDisplay() {
                // Combine both deck spectrums
                const canvas = document.getElementById('spectral-canvas');
                const ctx = canvas.getContext('2d');
                
                if (canvas.width !== canvas.offsetWidth) {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw combined spectrum
                ['a', 'b'].forEach((deck, index) => {
                    const deckData = this.state.decks[deck];
                    if (deckData.isPlaying && deckData.analyser) {
                        const bufferLength = deckData.analyser.frequencyBinCount;
                        const dataArray = new Uint8Array(bufferLength);
                        deckData.analyser.getByteFrequencyData(dataArray);
                        
                        const width = canvas.width / 2;
                        const height = canvas.height;
                        const barWidth = width / bufferLength * 2;
                        
                        for (let i = 0; i < bufferLength; i++) {
                            const barHeight = (dataArray[i] / 255) * height;
                            const x = (index * width) + (i * barWidth);
                            
                            const hue = index === 0 ? 280 : 200; // Purple for A, Cyan for B
                            ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.8)`;
                            ctx.fillRect(x, height - barHeight, barWidth - 1, barHeight);
                        }
                    }
                });
                
                // Draw crossfader position
                const crossfaderX = this.state.mixer.crossfaderPosition * canvas.width;
                ctx.strokeStyle = '#ec4899';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(crossfaderX, 0);
                ctx.lineTo(crossfaderX, canvas.height);
                ctx.stroke();
            }
        }

        // Initialize the application
        let neuralMixApp;
        
        document.addEventListener('DOMContentLoaded', function() {
            neuralMixApp = new NeuralMixApp();
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            if (neuralMixApp) {
                Object.values(neuralMixApp.waveformVisualizers).forEach(viz => {
                    viz.setupCanvas();
                });
                neuralMixApp.spectralVisualizer.setupCanvas();
            }
        });
    </script>
</body>
</html>