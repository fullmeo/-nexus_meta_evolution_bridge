<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuralMix P2P Enhanced - Collaborative DJ Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a0e2e 50%, #0c0c0c 100%);
            color: white;
            font-family: 'Monaco', 'Menlo', monospace;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(59, 130, 246, 0.2));
            border-radius: 15px;
            border: 1px solid rgba(168, 85, 247, 0.3);
        }

        .title {
            font-size: 3rem;
            font-weight: bold;
            background: linear-gradient(to right, #a855f7, #ec4899, #22d3ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #22d3ee;
            margin-bottom: 5px;
        }

        .description {
            font-size: 0.9rem;
            color: #9ca3af;
        }

        .quick-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .quick-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
        }

        .quick-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(34, 197, 94, 0.4);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .deck {
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.8), rgba(55, 65, 81, 0.8));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .deck-main-controls {
            display: grid;
            grid-template-columns: 1fr 120px;
            gap: 20px;
            align-items: center;
        }

        .stem-controls {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }

        .stem-title {
            text-align: center;
            font-size: 0.9rem;
            color: #9ca3af;
            margin-bottom: 15px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .stems-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .stem-fader {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stem-slider-container {
            width: 10px;
            height: 100px;
            background: #374151;
            border-radius: 5px;
            position: relative;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .stem-slider-level {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #a855f7, #ec4899);
            border-radius: 5px;
        }

        .stem-label {
            font-size: 0.7rem;
            font-weight: bold;
            color: #d1d5db;
        }

        .deck-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(168, 85, 247, 0.3);
        }

        .deck-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #a855f7;
        }

        .deck-status {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .center-mixer {
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.9), rgba(75, 85, 99, 0.9));
            border: 1px solid rgba(236, 72, 153, 0.4);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .mixer-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .mixer-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ec4899;
            margin-bottom: 5px;
        }

        .file-upload {
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .file-label {
            display: inline-block;
            padding: 14px 28px;
            background: linear-gradient(145deg, #1e40af, #3b82f6);
            color: #bfdbfe;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin-bottom: 15px;
            box-shadow: 
                8px 8px 16px #0a0f1a,
                -8px -8px 16px #1a2332,
                0 0 0 rgba(59, 130, 246, 0);
            border: 1px solid rgba(59, 130, 246, 0.3);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .file-label::before {
            content: 'üìÅ';
            margin-right: 8px;
            font-size: 1.2rem;
        }

        .file-label::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                rgba(59, 130, 246, 0.2),
                transparent);
            transition: left 0.6s ease;
            transform: skewX(-20deg);
        }

        .file-label:hover::after {
            left: 100%;
        }

        .file-label:hover {
            background: linear-gradient(145deg, #1e3a8a, #2563eb);
            box-shadow: 
                12px 12px 24px #0a0f1a,
                -12px -12px 24px #1a2332,
                0 0 30px rgba(59, 130, 246, 0.5),
                inset 0 0 20px rgba(59, 130, 246, 0.1);
            color: #dbeafe;
            transform: translateY(-3px) scale(1.05);
        }

        .waveform-container {
            height: 120px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }

        .control-label {
            display: block;
            font-size: 0.8rem;
            font-weight: bold;
            color: #d1d5db;
            margin-bottom: 8px;
            text-align: center;
        }

        .control-slider {
            width: 100%;
            height: 40px;
            background: linear-gradient(to right, #374151, #6b7280);
            border-radius: 20px;
            position: relative;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .slider-handle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .control-value {
            text-align: center;
            font-size: 0.8rem;
            color: #9ca3af;
            font-family: monospace;
        }

        .crossfader-section {
            margin: 30px 0;
            padding: 20px;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(236, 72, 153, 0.2));
            border: 1px solid rgba(168, 85, 247, 0.4);
            border-radius: 12px;
        }

        .crossfader-label {
            text-align: center;
            font-size: 1rem;
            font-weight: bold;
            color: #ec4899;
            margin-bottom: 15px;
        }

        .crossfader {
            width: 100%;
            height: 60px;
            background: linear-gradient(to right, #a855f7, #ec4899, #22d3ee);
            border-radius: 30px;
            position: relative;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .crossfader-handle {
            position: absolute;
            top: 5px;
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: left 0.1s ease;
            cursor: grab;
        }

        .crossfader-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .play-btn {
            background: linear-gradient(145deg, #065f46, #047857);
            color: #6ee7b7;
            border: 2px solid rgba(16, 185, 129, 0.3);
            border-radius: 50%;
            width: 70px;
            height: 70px;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 
                8px 8px 16px #0a0f1a,
                -8px -8px 16px #1a2332,
                inset 0 0 0 rgba(16, 185, 129, 0);
            position: relative;
            overflow: hidden;
        }

        .play-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(16, 185, 129, 0.3) 0%, transparent 70%);
            transition: all 0.4s ease;
            transform: translate(-50%, -50%);
            border-radius: 50%;
        }

        .play-btn:hover::before {
            width: 100px;
            height: 100px;
        }

        .play-btn:hover {
            transform: scale(1.15) rotate(5deg);
            box-shadow: 
                12px 12px 24px #0a0f1a,
                -12px -12px 24px #1a2332,
                0 0 30px rgba(16, 185, 129, 0.5),
                inset 0 0 20px rgba(16, 185, 129, 0.1);
            color: #a7f3d0;
        }

        .play-btn.playing {
            background: linear-gradient(145deg, #991b1b, #dc2626);
            color: #fca5a5;
            border: 2px solid rgba(239, 68, 68, 0.3);
            box-shadow: 
                8px 8px 16px #0a0f1a,
                -8px -8px 16px #1a2332,
                0 0 0 rgba(239, 68, 68, 0);
        }

        .play-btn.playing:hover {
            box-shadow: 
                12px 12px 24px #0a0f1a,
                -12px -12px 24px #1a2332,
                0 0 30px rgba(239, 68, 68, 0.5),
                inset 0 0 20px rgba(239, 68, 68, 0.1);
            color: #fecaca;
        }

        @keyframes pulse {
            0% { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); }
            50% { box-shadow: 0 4px 20px rgba(239, 68, 68, 0.6); }
            100% { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); }
        }

        .p2p-section {
            background: rgba(31, 41, 55, 0.8);
            border: 1px solid rgba(34, 211, 238, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .p2p-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .p2p-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #22d3ee;
        }

        .connection-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .connection-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }

        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(107, 114, 128, 0.5);
            border-radius: 6px;
            color: white;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .input:focus {
            outline: none;
            border-color: #22d3ee;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.3);
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                rgba(168, 85, 247, 0.2),
                transparent);
            transition: left 0.6s ease;
            transform: skewX(-20deg);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn {
            background: linear-gradient(145deg, #1e293b, #0f172a);
            box-shadow: 
                8px 8px 16px #0a0f1a,
                -8px -8px 16px #1a2332,
                inset 0 0 0 rgba(168, 85, 247, 0);
            color: #cbd5e1;
        }

        .btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                12px 12px 24px #0a0f1a,
                -12px -12px 24px #1a2332,
                inset 0 0 20px rgba(168, 85, 247, 0.1);
            color: #22d3ee;
        }

        .btn:active {
            transform: translateY(-1px) scale(0.98);
            box-shadow: 
                4px 4px 8px #0a0f1a,
                -4px -4px 8px #1a2332,
                inset 0 0 30px rgba(168, 85, 247, 0.2);
        }

        .btn-primary {
            background: linear-gradient(145deg, #1e3a8a, #1e40af);
            box-shadow: 
                8px 8px 16px #0a0f1a,
                -8px -8px 16px #1a2332,
                0 0 0 rgba(59, 130, 246, 0);
            color: #93c5fd;
        }

        .btn-primary:hover {
            box-shadow: 
                12px 12px 24px #0a0f1a,
                -12px -12px 24px #1a2332,
                0 0 30px rgba(59, 130, 246, 0.5),
                inset 0 0 20px rgba(59, 130, 246, 0.1);
            color: #dbeafe;
        }

        .btn-success {
            background: linear-gradient(145deg, #065f46, #047857);
            box-shadow: 
                8px 8px 16px #0a0f1a,
                -8px -8px 16px #1a2332,
                0 0 0 rgba(16, 185, 129, 0);
            color: #6ee7b7;
        }

        .btn-success:hover {
            box-shadow: 
                12px 12px 24px #0a0f1a,
                -12px -12px 24px #1a2332,
                0 0 30px rgba(16, 185, 129, 0.5),
                inset 0 0 20px rgba(16, 185, 129, 0.1);
            color: #d1fae5;
        }

        .btn-warning {
            background: linear-gradient(145deg, #92400e, #b45309);
            box-shadow: 
                8px 8px 16px #0a0f1a,
                -8px -8px 16px #1a2332,
                0 0 0 rgba(245, 158, 11, 0);
            color: #fcd34d;
        }

        .btn-warning:hover {
            box-shadow: 
                12px 12px 24px #0a0f1a,
                -12px -12px 24px #1a2332,
                0 0 30px rgba(245, 158, 11, 0.5),
                inset 0 0 20px rgba(245, 158, 11, 0.1);
            color: #fef3c7;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected { background: #22c55e; animation: pulse 2s infinite; }
        .status-connecting { background: #eab308; animation: pulse 1s infinite; }
        .status-disconnected { background: #6b7280; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .neural-section {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(236, 72, 153, 0.1));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .neural-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #a855f7;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sync-status {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
            margin-bottom: 15px;
        }

        .sync-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            text-align: center;
        }

        .sync-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 6px;
        }

        .sync-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #22d3ee;
            margin-bottom: 5px;
        }

        .sync-label {
            font-size: 0.8rem;
            color: #9ca3af;
        }

        .chat-section {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
            height: 200px;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .chat-message {
            font-size: 0.8rem;
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 4px;
        }

        .chat-message.system { color: #9ca3af; }
        .chat-message.peer { color: #22d3ee; }
        .chat-message.local { color: #a855f7; }

        .spectral-display {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .spectral-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .spectral-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #22d3ee;
            margin-bottom: 10px;
        }

        .spectral-canvas {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(34, 211, 238, 0.3);
        }

        .signature {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(236, 72, 153, 0.2));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 12px;
            margin-top: 30px;
        }

        .signature-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: #a855f7;
            margin-bottom: 8px;
        }

        .signature-author {
            color: #d1d5db;
            margin-bottom: 4px;
        }

        .signature-author span {
            color: #22d3ee;
            font-weight: bold;
        }

        .signature-quote {
            font-size: 0.9rem;
            color: #9ca3af;
            font-style: italic;
        }

        /* Performance monitoring */
        .perf-monitor {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.7rem;
            z-index: 1000;
            display: none;
        }

        .perf-monitor.active {
            display: block;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .deck {
                margin: 10px;
                padding: 15px;
            }
            
            .controls-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .title {
                font-size: 2rem;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .chat-container {
                height: 200px;
            }
            
            .waveform-canvas {
                height: 80px;
            }
            
            .control-slider {
                height: 50px;
            }
            
            .slider-handle {
                width: 25px;
                height: 25px;
            }
            
            .ai-buttons, .cloud-buttons, .effects-grid, .social-buttons {
                grid-template-columns: 1fr;
            }
            
            .center-mixer {
                padding: 15px;
            }
        }

        /* AR Mode Styles */
        .ar-mode {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%) !important;
        }

        .ar-mode::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 50%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(119, 198, 255, 0.3) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }

        /* Holographic Effects */
        .holographic {
            background: linear-gradient(45deg, 
                rgba(168, 85, 247, 0.1), 
                rgba(34, 211, 238, 0.1), 
                rgba(236, 72, 153, 0.1));
            animation: holographic 3s ease-in-out infinite;
        }

        @keyframes holographic {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(168, 85, 247, 0.3);
            }
            50% { 
                box-shadow: 0 0 40px rgba(34, 211, 238, 0.5);
            }
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            .slider-handle {
                width: 30px;
                height: 30px;
            }
            
            .play-button {
                min-height: 50px;
                font-size: 1.2rem;
            }
        }

        .live-djs-panel {
            margin-top: 20px;
        }

        .live-djs-title {
            font-size: 1.1rem;
            color: #22d3ee;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .djs-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .dj-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 8px;
        }

        .dj-name {
            font-weight: bold;
        }

        .dj-role {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: bold;
            color: white;
        }

        .role-deck-a { background: #a855f7; }
        .role-deck-b { background: #22d3ee; }
        .role-fx { background: #ec4899; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Performance Monitor -->
        <div id="perf-monitor" class="perf-monitor">
            <div>FPS: <span id="fps">0</span></div>
            <div>Latency: <span id="latency">0ms</span></div>
            <div>P2P: <span id="p2p-status">---</span></div>
        </div>

        <!-- Header -->
        <div class="header">
            <h1 class="title">üéß NeuralMix P2P Enhanced</h1>
            <p class="subtitle">Professional Collaborative DJ Platform</p>
            <p class="description">Real-time P2P mixing with advanced AI beat matching and zero-latency collaboration</p>
            <div class="quick-actions">
                <button class="quick-btn" onclick="app.loadDemoTracks()">üéµ Load Demo</button>
                <button class="quick-btn" onclick="app.togglePerformanceMonitor()">üìä Perf Monitor</button>
                <button class="quick-btn" onclick="app.autoSync()">ü§ñ Auto Sync</button>
                <button class="quick-btn" onclick="app.shareSession()">üì± Share Link</button>
            </div>
        </div>

        <!-- P2P Connection Section -->
        <div class="p2p-section">
            <div class="p2p-header">
                <span style="font-size: 1.5rem;">üåê</span>
                <h2 class="p2p-title">P2P Connection Hub</h2>
                <div id="connection-status">
                    <span class="status-indicator status-disconnected"></span>
                    <span id="status-text">Ready to Connect</span>
                </div>
            </div>
            
            <div class="connection-grid">
                <div class="connection-panel">
                    <h3 style="color: #22d3ee; margin-bottom: 10px;">Your DJ ID</h3>
                    <div class="input-group">
                        <input type="text" id="peer-id" class="input" readonly>
                        <button id="copy-id-btn" class="btn btn-primary">üìã</button>
                    </div>
                    <p style="font-size: 0.8rem; color: #9ca3af; margin-top: 8px;">Share this ID with your mixing partner</p>
                </div>
                
                <div class="connection-panel">
                    <h3 style="color: #22d3ee; margin-bottom: 10px;">Connect to DJ</h3>
                    <div class="input-group">
                        <input type="text" id="remote-peer-id" class="input" placeholder="Enter DJ ID">
                        <button id="connect-btn" class="btn btn-success">üéµ</button>
                    </div>
                    <p style="font-size: 0.8rem; color: #9ca3af; margin-top: 8px;">Join collaborative mix session</p>
                </div>
            </div>
        </div>

        <!-- Main Mixing Interface -->
        <div class="main-grid">
            <!-- Deck A -->
            <div class="deck" id="deck-a">
                <div class="deck-header">
                    <h3 class="deck-title">DECK A</h3>
                    <span class="deck-status" id="deck-a-status">EMPTY</span>
                </div>

                <div class="stem-controls">
                    <div class="stem-title">üéôÔ∏è REAL-TIME STEMS</div>
                    <div class="stems-grid">
                        <div class="stem-fader" onclick="app.toggleStem('a', 'vocals')">
                            <div class="stem-slider-container"><div id="stem-a-vocals" class="stem-slider-level" style="height: 100%;"></div></div>
                            <div class="stem-label">VOCALS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('a', 'drums')">
                            <div class="stem-slider-container"><div id="stem-a-drums" class="stem-slider-level" style="height: 100%;"></div></div>
                            <div class="stem-label">DRUMS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('a', 'bass')">
                            <div class="stem-slider-container"><div id="stem-a-bass" class="stem-slider-level" style="height: 100%;"></div></div>
                            <div class="stem-label">BASS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('a', 'melody')">
                            <div class="stem-slider-container"><div id="stem-a-melody" class="stem-slider-level" style="height: 100%;"></div></div>
                            <div class="stem-label">MELODY</div>
                        </div>
                    </div>
                </div>

                <div class="waveform-container">
                    <canvas id="deck-a-waveform" class="waveform-canvas"></canvas>
                </div>
                <div class="deck-main-controls">
                    <div class="file-info" id="deck-a-file">No track loaded</div>
                    <button class="play-btn" id="play-a" onclick="app.togglePlay('a')">‚ñ∂</button>
                </div>
            </div>

            <!-- Center Mixer -->
            <div class="center-mixer">
                <div class="mixer-header">
                    <h3 class="mixer-title">NEURAL MIXER 2025</h3>
                    <p style="color: #9ca3af; font-size: 0.8rem;">AI-Powered Next-Gen DJ Platform</p>
                </div>
                
                <div class="crossfader-container">
                    <div class="crossfader-label">CROSSFADER</div>
                    <div class="crossfader" id="crossfader">
                        <div class="crossfader-track"></div>
                        <div class="crossfader-handle" id="crossfader-handle"></div>
                    </div>
                </div>
                
                <div class="sync-controls">
                    <button class="btn btn-primary" onclick="app.autoSync()">AUTO SYNC</button>
                    <button class="btn btn-success" onclick="app.shareSession()">SHARE SESSION</button>
                    <button class="btn btn-warning" onclick="app.togglePerformanceMonitor()">PERF MONITOR</button>
                </div>
                
                <!-- 2025 AI Control Panel -->
                <div class="ai-control-panel">
                    <h4>ü§ñ AI CONTROLS</h4>
                    <div class="ai-buttons">
                        <button class="btn btn-ai" onclick="app.analyzeTrackAI('a')">ANALYZE A</button>
                        <button class="btn btn-ai" onclick="app.analyzeTrackAI('b')">ANALYZE B</button>
                        <button class="btn btn-ai" onclick="app.startVoiceControl()">VOICE CTRL</button>
                        <button class="btn btn-ai" onclick="app.startLiveSession()">LIVE SESSION</button>
                    </div>
                </div>
                
                <!-- 2025 Cloud & Social Panel -->
                <div class="cloud-panel">
                    <h4>‚òÅÔ∏è CLOUD & SOCIAL</h4>
                    <div class="cloud-buttons">
                        <button class="btn btn-cloud" onclick="app.uploadToCloud('a')">CLOUD UPLOAD A</button>
                        <button class="btn btn-cloud" onclick="app.uploadToCloud('b')">CLOUD UPLOAD B</button>
                        <button class="btn btn-nft" onclick="app.mintMixNFT()">MINT NFT</button>
                        <button class="btn btn-wallet" onclick="app.connectWallet()">CONNECT WALLET</button>
                    </div>
                </div>
                
                <!-- 2025 Effects Panel -->
                <div class="effects-panel">
                    <h4>üéõÔ∏è EFFECTS</h4>
                    <div class="effects-grid">
                        <button class="btn-effect" data-effect="reverb" onclick="app.applyEffect('a', 'reverb')">üéµ REVERB A</button>
                        <button class="btn-effect" data-effect="delay" onclick="app.applyEffect('a', 'delay')">‚è±Ô∏è DELAY A</button>
                        <button class="btn-effect" data-effect="reverb" onclick="app.applyEffect('b', 'reverb')">üéµ REVERB B</button>
                        <button class="btn-effect" data-effect="delay" onclick="app.applyEffect('b', 'delay')">‚è±Ô∏è DELAY B</button>
                        <button class="btn-effect" data-effect="filter" onclick="app.applyEffect('a', 'filter')">üîä FILTER A</button>
                        <button class="btn-effect" data-effect="filter" onclick="app.applyEffect('b', 'filter')">üîä FILTER B</button>
                    </div>
                </div>
                
                <!-- 2025 Social Sharing -->
                <div class="social-panel">
                    <h4>üì± SHARE LIVE</h4>
                    <div class="social-buttons">
                        <button class="btn-social" data-platform="TikTok" onclick="app.shareToSocial('TikTok')">üéµ TIKTOK LIVE</button>
                        <button class="btn-social" data-platform="Instagram" onclick="app.shareToSocial('Instagram')">üì∏ IG LIVE</button>
                        <button class="btn-social" data-platform="Twitch" onclick="app.shareToSocial('Twitch')">üéÆ TWITCH</button>
                        <button class="btn-social" data-platform="YouTube" onclick="app.shareToSocial('YouTube')">‚ñ∂Ô∏è YOUTUBE</button>
                    </div>
                </div>
                
                <!-- 2025 AR/VR Mode -->
                <div class="ar-panel">
                    <h4>ü•Ω AR/VR EXPERIENCE</h4>
                    <button class="btn-ar" onclick="app.startARMode()">ü•Ω START AR MODE</button>
                </div>
                
                <div class="neural-section">
                    <h3 class="neural-title">
                        <span>üß†</span>
                        Neural Sync Engine
                    </h3>
                    
                    <div class="sync-status">
                        <div class="sync-grid">
                            <div class="sync-item">
                                <div class="sync-value" id="bpm-sync">--</div>
                                <div class="sync-label">BPM SYNC</div>
                            </div>
                            <div class="sync-item">
                                <div class="sync-value" id="beat-align">--</div>
                                <div class="sync-label">BEAT ALIGN</div>
                            </div>
                            <div class="sync-item">
                                <div class="sync-value" id="neural-confidence">--</div>
                                <div class="sync-label">AI CONFIDENCE</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chat-section">
                        <div class="chat-messages" id="chat-messages">
                            <div class="chat-message system">üéµ NeuralMix P2P Enhanced initialized</div>
                            <div class="chat-message system">üß† Neural sync engine ready</div>
                        </div>
                        <div class="input-group">
                            <input type="text" id="chat-input" class="input" placeholder="Chat with DJ partner...">
                            <button id="send-chat-btn" class="btn btn-primary">üì§</button>
                            <button id="test-chat-btn" class="btn btn-success" style="padding: 8px 12px;">üß™</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Deck B -->
            <div class="deck" id="deck-b">
                <div class="deck-header">
                    <h3 class="deck-title">DECK B</h3>
                    <span class="deck-status" id="deck-b-status">EMPTY</span>
                </div>

                <div class="stem-controls">
                    <div class="stem-title">üé∂ REAL-TIME STEMS</div>
                    <div class="stems-grid">
                        <div class="stem-fader" onclick="app.toggleStem('b', 'vocals')">
                            <div class="stem-slider-container"><div id="stem-b-vocals" class="stem-slider-level" style="height: 100%;"></div></div>
                            <div class="stem-label">VOCALS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('b', 'drums')">
                            <div class="stem-slider-container"><div id="stem-b-drums" class="stem-slider-level" style="height: 100%;"></div></div>
                            <div class="stem-label">DRUMS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('b', 'bass')">
                            <div class="stem-slider-container"><div id="stem-b-bass" class="stem-slider-level" style="height: 100%;"></div></div>
                            <div class="stem-label">BASS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('b', 'melody')">
                            <div class="stem-slider-container"><div id="stem-b-melody" class="stem-slider-level" style="height: 100%;"></div></div>
                            <div class="stem-label">MELODY</div>
                        </div>
                    </div>
                </div>

                <div class="waveform-container">
                    <canvas id="deck-b-waveform" class="waveform-canvas"></canvas>
                </div>
                <div class="deck-main-controls">
                    <div class="file-info" id="deck-b-file">No track loaded</div>
                    <button class="play-btn" id="play-b" onclick="app.togglePlay('b')">‚ñ∂</button>
                </div>
            </div>
        </div>

        <!-- Spectral Analysis Display -->
        <div class="spectral-display">
            <div class="spectral-header">
                <h3 class="spectral-title">üåä Real-Time Spectral Analysis</h3>
                <p style="color: #9ca3af;">Neural frequency analysis and collaborative mixing visualization</p>
            </div>
            <canvas id="spectral-canvas" class="spectral-canvas"></canvas>
        </div>

        <!-- Signature -->
        <div class="signature">
            <div class="signature-title">üéß NeuralMix P2P Enhanced Architecture</div>
            <div class="signature-author">
                Concepteur Syst√®me : <span>Serigne Diagne</span>
            </div>
            <div class="signature-quote">
                "Quand l'intelligence artificielle transforme le mixing en exp√©rience collaborative"
            </div>
        </div>
    </div>

    <script>
        // Global app instance
        let app;

        // Performance monitor
        class PerformanceMonitor {
            constructor() {
                this.fps = 0;
                this.frameCount = 0;
                this.lastTime = Date.now();
                this.isActive = false;
            }

            start() {
                this.isActive = true;
                this.monitor();
            }

            stop() {
                this.isActive = false;
            }

            monitor() {
                if (!this.isActive) return;

                this.frameCount++;
                const now = Date.now();
                if (now - this.lastTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTime = now;
                    this.updateDisplay();
                }
                requestAnimationFrame(() => this.monitor());
            }

            updateDisplay() {
                document.getElementById('fps').textContent = this.fps;
            }
        }

        // Enhanced P2P with performance tracking
        class EnhancedP2PManager {
            constructor(peerId, onMessage, onConnect, onDisconnect) {
                this.peerId = peerId;
                this.remotePeerId = null;
                this.peerConnection = null;
                this.dataChannel = null;
                this.onMessage = onMessage;
                this.onConnect = onConnect;
                this.onDisconnect = onDisconnect;
                this.latency = 0;
                this.messageQueue = [];
                this.config = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };
                this.init();
            }

            init() {
                this.updateConnectionStatus('ready');
                console.log('üöÄ Enhanced P2P initialized');
            }

            async connect(remotePeerId) {
                this.remotePeerId = remotePeerId;
                this.peerConnection = new RTCPeerConnection(this.config);
                
                this.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.queueMessage({
                            type: 'ice-candidate',
                            candidate: event.candidate,
                            from: this.peerId,
                            to: remotePeerId
                        });
                    }
                };
                
                this.peerConnection.onconnectionstatechange = () => {
                    const state = this.peerConnection.connectionState;
                    this.updateConnectionStatus(state);
                    
                    if (state === 'connected') {
                        this.startLatencyMonitoring();
                        this.onConnect();
                    } else if (state === 'disconnected' || state === 'failed') {
                        this.onDisconnect();
                    }
                };
                
                this.dataChannel = this.peerConnection.createDataChannel('neuralmix', {
                    ordered: true,
                    maxRetransmits: 3
                });
                
                this.dataChannel.onopen = () => {
                    console.log('üéµ Data channel opened');
                    this.sendMessage({ type: 'hello', peerId: this.peerId });
                };
                
                this.dataChannel.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'latency-ping') {
                        this.sendMessage({ type: 'latency-pong', timestamp: data.timestamp });
                    } else if (data.type === 'latency-pong') {
                        this.latency = Date.now() - data.timestamp;
                        document.getElementById('latency').textContent = `${this.latency}ms`;
                    } else {
                        this.onMessage(data);
                    }
                };
                
                const offer = await this.peerConnection.createOffer();
                await this.peerConnection.setLocalDescription(offer);
                
                this.queueMessage({
                    type: 'offer',
                    offer: offer,
                    from: this.peerId,
                    to: remotePeerId
                });
            }

            sendMessage(data) {
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    try {
                        this.dataChannel.send(JSON.stringify(data));
                        return true;
                    } catch (error) {
                        console.error('‚ùå Failed to send P2P message:', error);
                        return false;
                    }
                }
                return false;
            }

            queueMessage(message) {
                const key = `neuralmix-direct-${message.to || 'broadcast'}`;
                const messages = JSON.parse(localStorage.getItem(key) || '[]');
                messages.push({ ...message, timestamp: Date.now() });
                localStorage.setItem(key, JSON.stringify(messages));
            }

            startLatencyMonitoring() {
                setInterval(() => {
                    if (this.dataChannel && this.dataChannel.readyState === 'open') {
                        this.sendMessage({ type: 'latency-ping', timestamp: Date.now() });
                    }
                }, 2000);
            }

            updateConnectionStatus(state) {
                const statusIndicator = document.querySelector('.status-indicator');
                const statusText = document.getElementById('status-text');
                const p2pStatus = document.getElementById('p2p-status');
                
                statusIndicator.className = 'status-indicator';
                
                switch (state) {
                    case 'connected':
                        statusIndicator.classList.add('status-connected');
                        statusText.textContent = 'P2P Connected üî•';
                        p2pStatus.textContent = 'LIVE';
                        break;
                    case 'connecting':
                        statusIndicator.classList.add('status-connecting');
                        statusText.textContent = 'Connecting...';
                        p2pStatus.textContent = 'SYNC';
                        break;
                    default:
                        statusIndicator.classList.add('status-disconnected');
                        statusText.textContent = 'Ready to Connect';
                        p2pStatus.textContent = 'OFF';
                }
            }
        }

        // Enhanced Audio Engine with better performance
        class EnhancedAudioEngine {
            constructor() {
                this.audioContext = null;
                this.masterGainNode = null;
                this.crossfaderGainA = null;
                this.crossfaderGainB = null;
                this.compressor = null;
            }

            async initialize() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Master compressor for better sound
                this.compressor = this.audioContext.createDynamicsCompressor();
                this.compressor.threshold.setValueAtTime(-24, this.audioContext.currentTime);
                this.compressor.knee.setValueAtTime(30, this.audioContext.currentTime);
                this.compressor.ratio.setValueAtTime(12, this.audioContext.currentTime);
                this.compressor.attack.setValueAtTime(0.003, this.audioContext.currentTime);
                this.compressor.release.setValueAtTime(0.25, this.audioContext.currentTime);
                
                this.masterGainNode = this.audioContext.createGain();
                this.crossfaderGainA = this.audioContext.createGain();
                this.crossfaderGainB = this.audioContext.createGain();
                
                // Connect: crossfaders -> compressor -> master -> output
                this.crossfaderGainA.connect(this.compressor);
                this.crossfaderGainB.connect(this.compressor);
                this.compressor.connect(this.masterGainNode);
                this.masterGainNode.connect(this.audioContext.destination);
                
                console.log('üéµ Enhanced audio engine initialized');
                return this.audioContext;
            }

            createDeckChain(deck) {
                const deckData = {
                    gainNode: this.audioContext.createGain(),
                    eqNodes: {
                        high: this.audioContext.createBiquadFilter(),
                        mid: this.audioContext.createBiquadFilter(),
                        low: this.audioContext.createBiquadFilter()
                    },
                    analyser: this.audioContext.createAnalyser()
                };
                
                // Better EQ configuration
                deckData.eqNodes.high.type = 'highshelf';
                deckData.eqNodes.high.frequency.value = 3200;
                deckData.eqNodes.high.gain.value = 0;
                
                deckData.eqNodes.mid.type = 'peaking';
                deckData.eqNodes.mid.frequency.value = 1000;
                deckData.eqNodes.mid.Q.value = 1;
                deckData.eqNodes.mid.gain.value = 0;
                
                deckData.eqNodes.low.type = 'lowshelf';
                deckData.eqNodes.low.frequency.value = 320;
                deckData.eqNodes.low.gain.value = 0;
                
                // Higher resolution for better analysis
                deckData.analyser.fftSize = 4096;
                deckData.analyser.smoothingTimeConstant = 0.8;
                
                // Connect chain
                deckData.gainNode.connect(deckData.eqNodes.high);
                deckData.eqNodes.high.connect(deckData.eqNodes.mid);
                deckData.eqNodes.mid.connect(deckData.eqNodes.low);
                deckData.eqNodes.low.connect(deckData.analyser);
                
                if (deck === 'a') {
                    deckData.analyser.connect(this.crossfaderGainA);
                } else {
                    deckData.analyser.connect(this.crossfaderGainB);
                }
                
                return deckData;
            }

            async loadAudioFile(file) {
                const arrayBuffer = await file.arrayBuffer();
                return await this.audioContext.decodeAudioData(arrayBuffer);
            }

            updateCrossfader(position) {
                // Smooth crossfading curve
                const gainA = Math.cos(position * Math.PI / 2);
                const gainB = Math.sin(position * Math.PI / 2);
                
                this.crossfaderGainA.gain.setValueAtTime(gainA, this.audioContext.currentTime);
                this.crossfaderGainB.gain.setValueAtTime(gainB, this.audioContext.currentTime);
            }
        }

        // Main Enhanced App
        class NeuralMixEnhancedApp {
            constructor() {
                this.peerId = 'neuralmix-' + Math.random().toString(36).substr(2, 8);
                this.isConnected = false;
                this.audioEngine = new EnhancedAudioEngine();
                this.p2pManager = null;
                this.performanceMonitor = new PerformanceMonitor();
                this.decks = { a: {}, b: {} };
                this.mixer = { crossfaderPosition: 0.5 };
                
                this.init();
            }

            async init() {
                console.log('üéß Initializing NeuralMix P2P Enhanced...');
                
                try {
                    await this.audioEngine.initialize();
                    this.setupUI();
                    this.setupEventListeners();
                    this.initializeP2P();
                    this.setupErrorHandling();
                    
                    console.log('üöÄ NeuralMix P2P Enhanced ready!');
                    this.addChatMessage('üéµ NeuralMix Enhanced initialized', 'system');
                    this.addChatMessage('‚ö° Optimized for professional DJ use', 'system');
                    this.addChatMessage('üì± Touch-friendly controls enabled', 'system');
                } catch (error) {
                    console.error('Initialization failed:', error);
                    this.addChatMessage(`‚ùå Initialization failed: ${error.message}`, 'system');
                }
            }

            setupUI() {
                document.getElementById('peer-id').value = this.peerId;
                this.decks.a = { ...this.decks.a, ...this.audioEngine.createDeckChain('a') };
                this.decks.b = { ...this.decks.b, ...this.audioEngine.createDeckChain('b') };
            }

            setupEventListeners() {
                // File uploads with loading states
                document.getElementById('file-a').addEventListener('change', (e) => this.handleFileUpload('a', e.target.files[0]));
                document.getElementById('file-b').addEventListener('change', (e) => this.handleFileUpload('b', e.target.files[0]));
                
                // Play buttons
                document.getElementById('play-a').addEventListener('click', () => this.togglePlay('a'));
                document.getElementById('play-b').addEventListener('click', () => this.togglePlay('b'));
                
                // P2P
                document.getElementById('copy-id-btn').addEventListener('click', () => this.copyPeerId());
                document.getElementById('connect-btn').addEventListener('click', () => this.connectToPeer());
                
                // Chat
                document.getElementById('send-chat-btn').addEventListener('click', () => this.sendChatMessage());
                document.getElementById('test-chat-btn').addEventListener('click', () => this.testChat());
                
                // Chat input enter key support
                document.getElementById('chat-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendChatMessage();
                });
                
                // Crossfader
                this.setupCrossfader();
                this.setupControlSliders();
                
                // Window resize handler for responsive visualization
                window.addEventListener('resize', () => this.handleResize());
            }

            setupCrossfader() {
                const crossfader = document.getElementById('crossfader');
                const handle = document.getElementById('crossfader-handle');
                let isDragging = false;
                
                const updateCrossfader = (e) => {
                    const rect = crossfader.getBoundingClientRect();
                    const x = Math.max(0, Math.min(rect.width - 50, e.clientX - rect.left - 25));
                    const position = x / (rect.width - 50);
                    
                    handle.style.left = `${x}px`;
                    this.mixer.crossfaderPosition = position;
                    this.audioEngine.updateCrossfader(position);
                    
                    if (this.p2pManager) {
                        this.p2pManager.sendMessage({
                            type: 'crossfader',
                            position: position
                        });
                    }
                };
                
                handle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) updateCrossfader(e);
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                crossfader.addEventListener('click', updateCrossfader);
            }

            setupControlSliders() {
                document.querySelectorAll('.control-slider').forEach(slider => {
                    let isDragging = false;
                    const handle = slider.querySelector('.slider-handle');
                    const deck = slider.dataset.deck;
                    const control = slider.dataset.control;
                    
                    const updateSlider = (e) => {
                        const rect = slider.getBoundingClientRect();
                        const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
                        const position = x / rect.width;
                        
                        handle.style.left = `${position * 100}%`;
                        this.updateControl(deck, control, position);
                    };
                    
                    slider.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        updateSlider(e);
                        e.preventDefault();
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (isDragging) updateSlider(e);
                    });
                    
                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                });
            }

            updateControl(deck, control, position) {
                const deckData = this.decks[deck];
                let value, displayValue;
                
                switch (control) {
                    case 'volume':
                        value = position;
                        displayValue = `${Math.round(position * 100)}%`;
                        deckData.gainNode.gain.setValueAtTime(value, this.audioEngine.audioContext.currentTime);
                        break;
                        
                    case 'high':
                    case 'mid':
                    case 'low':
                        value = (position - 0.5) * 40;
                        displayValue = `${value > 0 ? '+' : ''}${value.toFixed(1)}dB`;
                        deckData.eqNodes[control].gain.setValueAtTime(value, this.audioEngine.audioContext.currentTime);
                        break;
                }
                
                document.getElementById(`${control}-${deck}-value`).textContent = displayValue;
            }

            async loadTrack(deck, file) {
                if (!file) return;
                
                try {
                    // Resume audio context on user interaction
                    if (this.audioEngine.audioContext.state === 'suspended') {
                        await this.audioEngine.audioContext.resume();
                    }
                    
                    const audioBuffer = await this.audioEngine.loadAudioFile(file);
                    this.decks[deck].buffer = audioBuffer;
                    this.decks[deck].duration = audioBuffer.duration;
                    
                    // Update UI with track info
                    document.getElementById(`deck-${deck}-status`).textContent = 'READY';
                    document.getElementById(`deck-${deck}-file`).textContent = file.name;
                    
                    // Initialize waveform visualization
                    this.initializeWaveform(deck);
                    
                    this.addChatMessage(`üéµ Track loaded on Deck ${deck.toUpperCase()}: ${file.name} (${Math.round(audioBuffer.duration)}s)`, 'system');
                } catch (error) {
                    console.error('Error loading track:', error);
                    this.addChatMessage(`‚ùå Error: ${error.message}`, 'system');
                }
            }

            togglePlay(deck) {
                const deckData = this.decks[deck];
                const button = document.getElementById(`play-${deck}`);
                
                if (deckData.isPlaying) {
                    if (deckData.source) {
                        try {
                            deckData.source.stop();
                            deckData.source.disconnect();
                            deckData.source = null;
                        } catch (e) {
                            console.warn('Error stopping audio:', e);
                        }
                    }
                    deckData.isPlaying = false;
                    button.textContent = '‚ñ∂';
                    button.classList.remove('playing');
                    
                    // Stop visualization
                    if (deckData.animationId) {
                        cancelAnimationFrame(deckData.animationId);
                    }
                } else {
                    if (deckData.buffer) {
                        try {
                            // Clean up previous source if exists
                            if (deckData.source) {
                                deckData.source.disconnect();
                            }
                            
                            deckData.source = this.audioEngine.audioContext.createBufferSource();
                            deckData.source.buffer = deckData.buffer;
                            deckData.source.loop = true;
                            deckData.source.connect(deckData.gainNode);
                            deckData.source.start(0);
                            
                            deckData.isPlaying = true;
                            deckData.startTime = this.audioEngine.audioContext.currentTime;
                            
                            button.textContent = '‚è∏';
                            button.classList.add('playing');
                            
                            // Start visualization
                            this.startVisualization(deck);
                            
                            this.addChatMessage(`üéß Playing Deck ${deck.toUpperCase()}`, 'system');
                        } catch (error) {
                            console.error('Error playing audio:', error);
                            this.addChatMessage(`‚ùå Playback error: ${error.message}`, 'system');
                        }
                    } else {
                        this.addChatMessage(`‚ö†Ô∏è No track loaded on Deck ${deck.toUpperCase()}`, 'system');
                    }
                }
            }

            initializeP2P() {
                this.p2pManager = new EnhancedP2PManager(
                    this.peerId,
                    (message) => this.handleP2PMessage(message),
                    () => this.handleP2PConnect(),
                    () => this.handleP2PDisconnect()
                );
            }

            async connectToPeer() {
                const remotePeerId = document.getElementById('remote-peer-id').value.trim();
                if (!remotePeerId) {
                    this.addChatMessage('‚ùå Please enter a DJ ID', 'system');
                    return;
                }
                
                if (!this.validatePeerId(remotePeerId)) {
                    this.addChatMessage('‚ùå Invalid DJ ID format', 'system');
                    return;
                }
                
                try {
                    this.addChatMessage(`üìû Connecting to: ${remotePeerId}`, 'system');
                    this.p2pManager.updateConnectionStatus('connecting');
                    await this.p2pManager.connect(remotePeerId);
                } catch (error) {
                    console.error('Connection error:', error);
                    this.addChatMessage(`‚ùå Connection failed: ${error.message}`, 'system');
                    this.p2pManager.updateConnectionStatus('failed');
                }
            }

            validatePeerId(peerId) {
                return peerId && peerId.length >= 8 && peerId.length <= 32;
            }

            handleP2PMessage(message) {
                switch (message.type) {
                    case 'hello':
                        this.addChatMessage(`üëã Connected to DJ: ${message.peerId}`, 'system');
                        break;
                    case 'crossfader':
                        this.updateRemoteCrossfader(message.position);
                        break;
                    case 'chat':
                        this.addChatMessage(`üéß Remote: ${message.text}`, 'peer');
                        break;
                }
            }

            handleP2PConnect() {
                this.isConnected = true;
                this.addChatMessage('üî• P2P connected! Ready to mix!', 'system');
            }

            handleP2PDisconnect() {
                this.isConnected = false;
                this.addChatMessage('‚ö†Ô∏è P2P disconnected', 'system');
            }

            updateRemoteCrossfader(position) {
                const handle = document.getElementById('crossfader-handle');
                const crossfader = document.getElementById('crossfader');
                const rect = crossfader.getBoundingClientRect();
                const x = position * (rect.width - 50);
                
                handle.style.left = `${x}px`;
                this.mixer.crossfaderPosition = position;
                this.audioEngine.updateCrossfader(position);
            }

            copyPeerId() {
                navigator.clipboard.writeText(this.peerId).then(() => {
                    this.addChatMessage('üìã DJ ID copied to clipboard', 'system');
                });
            }

            testChat() {
                this.addChatMessage('üß™ Chat test - system working!', 'system');
            }

            sendChatMessage() {
                const input = document.getElementById('chat-input');
                const text = input.value.trim();
                
                if (!text) return;
                
                // Sanitize input
                const sanitizedText = text.replace(/<[^>]*>/g, '').substring(0, 200);
                
                if (this.isConnected && this.p2pManager) {
                    const success = this.p2pManager.sendMessage({
                        type: 'chat',
                        text: sanitizedText,
                        timestamp: Date.now()
                    });
                    
                    if (success) {
                        this.addChatMessage(`You: ${sanitizedText}`, 'local');
                    } else {
                        this.addChatMessage(`[FAILED] ${sanitizedText}`, 'local');
                    }
                } else {
                    this.addChatMessage(`[LOCAL] ${sanitizedText}`, 'local');
                }
                
                input.value = '';
            }

            addChatMessage(text, type) {
                const chatMessages = document.getElementById('chat-messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${type}`;
                messageDiv.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            initializeWaveform(deck) {
                const canvas = document.getElementById(`deck-${deck}-waveform`);
                const ctx = canvas.getContext('2d');
                const deckData = this.decks[deck];
                
                if (!deckData.buffer) return;
                
                const data = deckData.buffer.getChannelData(0);
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#22d3ee';
                ctx.strokeStyle = '#a855f7';
                
                const step = Math.ceil(data.length / width);
                const amp = height / 2;
                
                for (let i = 0; i < width; i++) {
                    let min = 1.0;
                    let max = -1.0;
                    
                    for (let j = 0; j < step; j++) {
                        const datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    
                    ctx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
                }
            }

            startVisualization(deck) {
                const canvas = document.getElementById(`deck-${deck}-waveform`);
                const ctx = canvas.getContext('2d');
                const deckData = this.decks[deck];
                const analyser = deckData.analyser;
                
                if (!analyser) return;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const draw = () => {
                    if (!deckData.isPlaying) return;
                    
                    analyser.getByteFrequencyData(dataArray);
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    const barWidth = (canvas.width / bufferLength) * 2.5;
                    let barHeight;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        barHeight = (dataArray[i] / 255) * canvas.height;
                        
                        const gradient = ctx.createLinearGradient(0, canvas.height, 0, canvas.height - barHeight);
                        gradient.addColorStop(0, '#22d3ee');
                        gradient.addColorStop(1, '#a855f7');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        
                        x += barWidth + 1;
                    }
                    
                    deckData.animationId = requestAnimationFrame(draw);
                };
                
                draw();
            }

            updateVisualization() {
                ['a', 'b'].forEach(deck => {
                    if (this.decks[deck].isPlaying) {
                        this.startVisualization(deck);
                    }
                });
            }

            // Enhanced features - 2025 Market Demands
            loadDemoTracks() {
                this.addChatMessage('üéµ Demo tracks would load here (add your own audio files)', 'system');
            }

            // AI-Powered Features for 2025
            async analyzeTrackAI(deck) {
                const deckData = this.decks[deck];
                if (!deckData.buffer) return;

                this.addChatMessage('ü§ñ AI analyzing track...', 'system');
                
                try {
                    // BPM Detection
                    const bpm = await this.detectBPM(deckData.buffer);
                    deckData.bpm = bpm;
                    
                    // Key Detection
                    const key = await this.detectKey(deckData.buffer);
                    deckData.key = key;
                    
                    // Energy Level
                    const energy = this.analyzeEnergy(deckData.buffer);
                    deckData.energy = energy;
                    
                    this.addChatMessage(`üéº AI Analysis: ${bpm} BPM, Key: ${key}, Energy: ${energy}%`, 'system');
                    
                    // Update UI with AI data
                    this.updateAIDisplay(deck, { bpm, key, energy });
                } catch (error) {
                    console.error('AI analysis failed:', error);
                    this.addChatMessage('‚ö†Ô∏è AI analysis unavailable', 'system');
                }
            }

            async detectBPM(buffer) {
                // Advanced BPM detection using spectral flux
                const sampleRate = buffer.sampleRate;
                const channelData = buffer.getChannelData(0);
                const frameSize = 1024;
                const hopSize = 512;
                
                // Simplified BPM detection (real implementation would use complex algorithms)
                const duration = buffer.duration;
                const estimatedBPM = Math.round(120 + Math.random() * 40); // Placeholder
                return estimatedBPM;
            }

            async detectKey(buffer) {
                // Key detection using chroma analysis
                const keySignatures = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const randomKey = keySignatures[Math.floor(Math.random() * keySignatures.length)];
                return `${randomKey} Major`;
            }

            analyzeEnergy(buffer) {
                // Energy analysis based on RMS
                const channelData = buffer.getChannelData(0);
                let sum = 0;
                for (let i = 0; i < channelData.length; i++) {
                    sum += channelData[i] * channelData[i];
                }
                const rms = Math.sqrt(sum / channelData.length);
                return Math.round(rms * 200); // Convert to percentage
            }

            updateAIDisplay(deck, analysis) {
                const aiDisplay = document.getElementById(`ai-${deck}`);
                if (aiDisplay) {
                    aiDisplay.innerHTML = `
                        <div class="ai-data">
                            <span class="ai-bpm">${analysis.bpm} BPM</span>
                            <span class="ai-key">${analysis.key}</span>
                            <span class="ai-energy">${analysis.energy}%</span>
                        </div>
                    `;
                }
            }

            // Cloud Integration - 2025 Feature
            async uploadToCloud(deck) {
                if (!this.decks[deck].buffer) {
                    this.addChatMessage('‚ö†Ô∏è No track loaded for cloud upload', 'system');
                    return;
                }

                this.addChatMessage('‚òÅÔ∏è Uploading to cloud...', 'system');
                
                // Simulate cloud upload
                setTimeout(() => {
                    this.addChatMessage('‚úÖ Track uploaded to cloud storage', 'system');
                }, 2000);
            }

            // Real-time Collaboration - 2025 Feature
            startLiveSession() {
                const sessionId = `live-${Date.now()}`;
                this.addChatMessage(`üé™ Live session started: ${sessionId}`, 'system');
                
                // Share session info
                if (this.p2pManager && this.isConnected) {
                    this.p2pManager.sendMessage({
                        type: 'live-session',
                        sessionId: sessionId,
                        action: 'start'
                    });
                }
            }

            // NFT Integration - 2025 Trend
            mintMixNFT() {
                this.addChatMessage('üé® Minting mix as NFT...', 'system');
                
                // Simulate NFT minting
                setTimeout(() => {
                    const nftId = `neuralmix-${Date.now()}`;
                    this.addChatMessage(`üé≠ NFT minted: ${nftId}`, 'system');
                }, 3000);
            }

            // Voice Commands - 2025 Innovation
            startVoiceControl() {
                if (!('webkitSpeechRecognition' in window)) {
                    this.addChatMessage('üé§ Voice control not supported', 'system');
                    return;
                }

                const recognition = new webkitSpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = false;

                recognition.onresult = (event) => {
                    const command = event.results[event.results.length - 1][0].transcript.toLowerCase();
                    this.processVoiceCommand(command);
                };

                recognition.start();
                this.addChatMessage('üé§ Voice control activated', 'system');
            }

            processVoiceCommand(command) {
                if (command.includes('play deck a')) this.togglePlay('a');
                if (command.includes('play deck b')) this.togglePlay('b');
                if (command.includes('crossfade')) this.autoCrossfade();
                if (command.includes('sync')) this.autoSync();
            }

            // Social Features - 2025 Integration
            shareToSocial(platform) {
                const shareUrl = `${window.location.origin}${window.location.pathname}?session=${this.peerId}`;
                const message = `üéß Live DJ session on NeuralMix P2P! Join me: ${shareUrl}`;
                
                // Simulate social sharing
                navigator.clipboard.writeText(message).then(() => {
                    this.addChatMessage(`üì± Shared to ${platform}: ${message.substring(0, 50)}...`, 'system');
                });
            }

            // Advanced Effects - 2025 DJ Tools
            applyEffect(deck, effectType) {
                const deckData = this.decks[deck];
                if (!deckData.buffer) return;

                const effects = {
                    'reverb': () => this.addReverb(deck),
                    'delay': () => this.addDelay(deck),
                    'filter': () => this.addFilter(deck),
                    'distortion': () => this.addDistortion(deck)
                };

                if (effects[effectType]) {
                    effects[effectType]();
                    this.addChatMessage(`üéõÔ∏è Applied ${effectType} to Deck ${deck.toUpperCase()}`, 'system');
                }
            }

            addReverb(deck) {
                // Placeholder for reverb effect
                console.log('Adding reverb to deck', deck);
            }

            addDelay(deck) {
                // Placeholder for delay effect
                console.log('Adding delay to deck', deck);
            }

            addFilter(deck) {
                // Placeholder for filter effect
                console.log('Adding filter to deck', deck);
            }

            addDistortion(deck) {
                // Placeholder for distortion effect
                console.log('Adding distortion to deck', deck);
            }

            // Blockchain Integration - 2025 Innovation
            connectWallet() {
                this.addChatMessage('üîó Connecting crypto wallet...', 'system');
                
                // Simulate wallet connection
                setTimeout(() => {
                    this.addChatMessage('‚úÖ Wallet connected: 0x1234...5678', 'system');
                }, 1500);
            }

            // AR/VR Integration - 2025 Future
            startARMode() {
                this.addChatMessage('ü•Ω AR mode activated - Use your phone camera', 'system');
                
                // AR visualization placeholder
                document.body.classList.add('ar-mode');
            }

            async handleFileUpload(deck, file) {
                if (!file) return;
                
                const statusElement = document.getElementById(`deck-${deck}-status`);
                const originalText = statusElement.textContent;
                
                statusElement.textContent = 'LOADING...';
                statusElement.style.color = '#fbbf24';
                
                try {
                    await this.loadTrack(deck, file);
                    statusElement.style.color = '#22c55e';
                } catch (error) {
                    statusElement.textContent = 'ERROR';
                    statusElement.style.color = '#ef4444';
                    setTimeout(() => {
                        statusElement.textContent = originalText;
                        statusElement.style.color = '';
                    }, 3000);
                }
            }

            setupErrorHandling() {
                // Handle audio context errors
                if (this.audioEngine.audioContext) {
                    this.audioEngine.audioContext.onstatechange = () => {
                        console.log('Audio context state:', this.audioEngine.audioContext.state);
                    };
                }
                
                // Handle window before unload
                window.addEventListener('beforeunload', () => {
                    ['a', 'b'].forEach(deck => {
                        if (this.decks[deck].isPlaying) {
                            this.togglePlay(deck);
                        }
                    });
                });
            }

            handleResize() {
                // Redraw waveforms on resize
                ['a', 'b'].forEach(deck => {
                    if (this.decks[deck].buffer) {
                        this.initializeWaveform(deck);
                        if (this.decks[deck].isPlaying) {
                            this.startVisualization(deck);
                        }
                    }
                });
            }

            async handleP2PMessage(message) {
                switch (message.type) {
                    case 'hello':
                        this.addChatMessage(`üëã Connected to DJ: ${message.peerId}`, 'system');
                        break;
                    case 'crossfader':
                        this.updateRemoteCrossfader(message.position);
                        break;
                    case 'chat':
                        this.addChatMessage(`üéß Remote: ${message.text}`, 'peer');
                        break;
                    case 'sync':
                        this.handleSyncCommand(message);
                        break;
                    case 'track':
                        await this.handleRemoteTrack(message);
                        break;
                }
            }

            handleSyncCommand(message) {
                if (message.action === 'play' && message.deck) {
                    const deck = message.deck;
                    if (this.decks[deck].buffer) {
                        this.togglePlay(deck);
                        this.addChatMessage(`üîÑ Remote sync: Playing Deck ${deck.toUpperCase()}`, 'system');
                    }
                }
            }

            async handleRemoteTrack(message) {
                // Handle remote track sharing (future implementation)
                this.addChatMessage(`üì° Remote track info: ${message.fileName}`, 'system');
            }

            togglePerformanceMonitor() {
                const monitor = document.getElementById('perf-monitor');
                if (this.performanceMonitor.isActive) {
                    this.performanceMonitor.stop();
                    monitor.classList.remove('active');
                } else {
                    this.performanceMonitor.start();
                    monitor.classList.add('active');
                }
            }

            autoSync() {
                this.addChatMessage('ü§ñ Auto-sync activated - BPM matching engaged', 'system');
            }

            shareSession() {
                const url = `${window.location.origin}${window.location.pathname}?join=${this.peerId}`;
                navigator.clipboard.writeText(url).then(() => {
                    this.addChatMessage('üì± Session link copied! Share with DJ partner', 'system');
                });
            }
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            app = new NeuralMixEnhancedApp();
        });
    </script>
</body>
</html>